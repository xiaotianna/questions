# äºŒå‰æ ‘

## 1. äºŒå‰æ ‘çš„å‰åºéå†

<LeetCodeLink url="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/" />

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„**å‰åºéå†**ã€‚

**ç¤ºä¾‹ 1**ï¼š

> **è¾“å…¥**ï¼šroot = [1,null,2,3]
>
> **è¾“å‡º**ï¼š[1,2,3]
>
> **è§£é‡Š**ï¼š
>
> ![](./img/å‰åºéå†-1.png)

**ç¤ºä¾‹ 2**ï¼š

> **è¾“å…¥**ï¼šroot = [1,2,3,4,5,null,8,null,null,6,7,9]
>
> **è¾“å‡º**ï¼š[1,2,4,5,6,7,3,8,9]
>
> **è§£é‡Š**ï¼š
>
> ![](./img/å‰åºéå†-2.png)

**ç¤ºä¾‹ 3**ï¼š

> **è¾“å…¥**ï¼šroot = []
>
> **è¾“å‡º**ï¼š[]

**ç¤ºä¾‹ 4**ï¼š

> **è¾“å…¥**ï¼šroot = [1]
>
> **è¾“å‡º**ï¼š[1]

::: code-group

```md [æ€è·¯]
è¿™ä¸ªå‰åºéå†åœ¨ã€äºŒå‰æ ‘åŸºç¡€çŸ¥è¯†ã€‘éƒ¨åˆ†å·²ç»è¯´è¿‡äº†ï¼Œåˆ†ä¸ºé€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•

è¦æ³¨æ„ä½¿ç”¨é€’å½’çš„æ—¶å€™ï¼Œres çš„åˆå§‹åŒ–å°½é‡é˜²æ­¢å‚æ•°ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨é—­åŒ…ï¼Œä¾‹å¦‚ï¼š
var inorderTraversal = function(root) {
**é—­åŒ…**
const res = []
function inorder(node) {
if (!node) return
inorder(node.left)
res.push(node.val)
inorder(node.right)
}
inorder(root)
return res
}
å¦‚æœå°† res æ•°ç»„åœ¨å‡½æ•°å†…éƒ¨åˆå§‹åŒ–ï¼Œä¼šå¯¼è‡´æ¯æ¬¡é€’å½’è°ƒç”¨éƒ½åˆ›å»ºä¸€ä¸ªæ–°çš„ç©ºæ•°ç»„ï¼Œè€Œä¸æ˜¯åœ¨åŒä¸€ä¸ªæ•°ç»„ä¸Šç´¯ç§¯ç»“æœã€‚
```

```js [é€’å½’æ³•]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root, res = []) {
  if (!root) return []
  // ä¸­
  res.push(root.val)
  // å·¦
  preorderTraversal(root.left, res)
  // å³
  preorderTraversal(root.right, res)
  return res
}
```

```js [ç»Ÿä¸€è¿­ä»£æ³•]
// è¿­ä»£æ³•
var preorderTraversal = function (root) {
  if (!root) return []

  const result = []
  // âš ï¸æ³¨æ„ï¼šéœ€è¦åˆå§‹åŒ–æ ˆ
  const stack = [root]

  while (stack.length > 0) {
    const node = stack.pop()

    if (node === null) {
      const curNode = stack.pop()
      result.push(curNode.val)
    } else {
      // éå†ï¼šä¸­å·¦å³
      // æ ˆå­˜æ”¾ï¼šå³å·¦ä¸­
      // å³
      node.right && stack.push(node.right)
      // å·¦
      node.left && stack.push(node.left)
      // ä¸­
      stack.push(node)
      stack.push(null)
    }
  }

  return result
}
```

:::

## 2. äºŒå‰æ ‘çš„ä¸­åºéå†

<LeetCodeLink url="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" />

è¿™é“é¢˜åœ¨ã€äºŒå‰æ ‘åŸºç¡€ã€‘ä¸­æœ‰è¯´ï¼Œå’Œç¬¬ä¸€é¢˜å·®ä¸å¤šï¼Œåªæ˜¯äº¤æ¢é€’å½’/éå†çš„é¡ºåºå³å¯ã€‚

## 3. äºŒå‰æ ‘çš„ååºéå†

<LeetCodeLink url="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/" />

è¿™é“é¢˜åœ¨ã€äºŒå‰æ ‘åŸºç¡€ã€‘ä¸­æœ‰è¯´ï¼Œå’Œç¬¬ä¸€é¢˜å·®ä¸å¤šï¼Œåªæ˜¯äº¤æ¢é€’å½’/éå†çš„é¡ºåºå³å¯ã€‚

## ğŸš€ â¬‡ï¸ äºŒå‰æ ‘å±‚åºéå†

## 4. äºŒå‰æ ‘çš„å±‚åºéå†

<LeetCodeLink url="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/" />

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **å±‚åºéå†** ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/äºŒå‰æ ‘éå†-lc-102.jpg)

> è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
>
> è¾“å‡ºï¼š[[3],[9,20],[15,7]]

**ç¤ºä¾‹ 2**ï¼š

> è¾“å…¥ï¼šroot = [1]
>
> è¾“å‡ºï¼š[[1]]

**ç¤ºä¾‹ 3**ï¼š

> è¾“å…¥ï¼šroot = []
>
> è¾“å‡ºï¼š[]

::: code-group

```md [æ€è·¯]
é€’å½’æ³•ï¼ˆæ·±åº¦ä¼˜å…ˆï¼‰ï¼šåªéœ€è¦è€ƒè™‘å½“å‰èŠ‚ç‚¹çš„å’Œå®ƒçš„å·¦å³å­èŠ‚ç‚¹ï¼Œå¹¶é€’å½’å¤„ç†ã€‚
è¿­ä»£æ³•ï¼ˆå¹¿åº¦ä¼˜å…ˆï¼‰ï¼šéœ€è¦è®°å½•å½“å‰å±‚çš„èŠ‚ç‚¹ï¼Œå¹¶éå†å½“å‰å±‚çš„èŠ‚ç‚¹ï¼Œå¹¶è®°å½•ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ã€‚
```

```js [é€’å½’æ³•]
var levelOrder = function (root) {
  if (!root) return []
  let res = []
  dfs(root, 0, res)
  return res
}

function dfs(root, step, res) {
  if (!root) return
  if (!res[step]) res[step] = []
  res[step].push(root.val)
  root.left && dfs(root.left, step + 1, res)
  root.right && dfs(root.right, step + 1, res)
}
```

```js [è¿­ä»£æ³•]
var levelOrder = function (root) {
  if (!root) return []
  const res = []
  const queue = [root]

  while (queue.length > 0) {
    const level_size = queue.length
    const cur_res = []

    for (let i = 0; i < level_size; i++) {
      // å¤„ç†å½“å‰å…ƒç´ 
      let cur_node = queue.shift()
      cur_res.push(cur_node.val)

      // å¤„ç†å­èŠ‚ç‚¹
      cur_node.left && queue.push(cur_node.left)
      cur_node.right && queue.push(cur_node.right)
    }

    res.push(cur_res)
  }
  return res
}
```

:::

## 5. äºŒå‰æ ‘çš„å±‚åºéå† II

<LeetCodeLink url="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/" />

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼ **è‡ªåº•å‘ä¸Šçš„å±‚åºéå†** ã€‚ ï¼ˆå³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†ï¼‰

**ç¤ºä¾‹ 1**ï¼š

![](./img/äºŒå‰æ ‘éå†-lc-102.jpg)

> è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
>
> è¾“å‡ºï¼š[[15,7],[9,20],[3]]

**ç¤ºä¾‹ 2**ï¼š

> è¾“å…¥ï¼šroot = [1]
>
> è¾“å‡ºï¼š[[1]]

**ç¤ºä¾‹ 3**ï¼š

> è¾“å…¥ï¼šroot = []
>
> è¾“å‡ºï¼š[]

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜å’Œä¸Šä¸€é¢˜éå¸¸ç±»ä¼¼ï¼Œåªæ˜¯éœ€è¦å°†è¾“å‡ºçš„äºŒç»´æ•°ç»„è¿›è¡Œåè½¬ï¼Œ
å¯ä»¥åœ¨ä¸Šä¸€é¢˜ä¸­æœ€åå°†æ¯ä¸€å±‚ push è¿›å»çš„æ—¶å€™ï¼Œç›´æ¥æ”¾åœ¨æœ€å‰é¢ï¼ˆä½¿ç”¨ unshiftï¼‰
```

```js [è¿­ä»£æ³•ï¼ˆå¹¿åº¦ä¼˜å…ˆï¼‰]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrderBottom = function (root) {
  if (!root) return []
  let res = []
  let queue = [root]

  while (queue.length > 0) {
    const level_size = queue.length
    const level_res = []
    for (let i = 0; i < level_size; i++) {
      const node = queue.shift()
      // å½“å‰èŠ‚ç‚¹
      level_res.push(node.val)
      // å·¦
      node.left && queue.push(node.left)
      // å³
      node.right && queue.push(node.right)
    }
    res.unshift(level_res) // [!code ++]
  }
  return res
}
```

:::

## 6. äºŒå‰æ ‘çš„å³è§†å›¾

<LeetCodeLink url="https://leetcode.cn/problems/binary-tree-right-side-view/description/" />

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ `root`ï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚

**ç¤ºä¾‹ 1**ï¼š

> è¾“å…¥ï¼šroot = [1,2,3,null,5,null,4]
>
> è¾“å‡ºï¼š[1,3,4]
>
> è§£é‡Šï¼š
>
> ![](./img/äºŒå‰æ ‘çš„å³è§†å›¾-1.png)

**ç¤ºä¾‹ 2**ï¼š

> è¾“å…¥ï¼šroot = [1,2,3,4,null,null,null,5]
>
> è¾“å‡ºï¼š[1,3,4,5]
>
> è§£é‡Šï¼š
>
> ![](./img/äºŒå‰æ ‘çš„å³è§†å›¾-2.png)

**ç¤ºä¾‹ 3**ï¼š

> è¾“å…¥ï¼šroot = [1,null,3]
>
> è¾“å‡ºï¼š[1,3]

**ç¤ºä¾‹ 4**ï¼š

> è¾“å…¥ï¼šroot = []
>
> è¾“å‡ºï¼š[]

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜çš„æ€è·¯ï¼Œæœ¬è´¨è¿˜æ˜¯å±‚åºéå†ï¼Œä½†æ˜¯éœ€è¦è®°å½•æ¯ä¸€å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚
ç»“æœåªéœ€è¦ push åˆ°æœ€åçš„ç»“æœæ•°ç»„å³å¯ï¼Œä¸ç”¨æ¯å±‚åˆ›å»ºä¸€ä¸ªæ•°ç»„ã€‚
```

```c [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function (root) {
  if (!root) return []
  const res = []
  const queue = [root]

  while (queue.length > 0) {
    const level_size = queue.length

    for (let i = 0; i < level_size; i++) {
      // å½“å‰èŠ‚ç‚¹
      const node = queue.shift()
      // åªpushæœ«å°¾èŠ‚ç‚¹
      if (i === level_size - 1) { // [!code ++]
        res.push(node.val) // [!code ++]
      } // [!code ++]
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return res
}
```

:::

## 7. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼

<LeetCodeLink url="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/" />

ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root , ä»¥æ•°ç»„çš„å½¢å¼è¿”å›æ¯ä¸€å±‚èŠ‚ç‚¹çš„å¹³å‡å€¼ã€‚ä¸å®é™…ç­”æ¡ˆç›¸å·® 10 çš„-5 æ¬¡æ–¹ ä»¥å†…çš„ç­”æ¡ˆå¯ä»¥è¢«æ¥å—ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼-1.jpg)

> è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
>
> è¾“å‡ºï¼š[3.00000,14.50000,11.00000]
>
> è§£é‡Šï¼šç¬¬ 0 å±‚çš„å¹³å‡å€¼ä¸º 3,ç¬¬ 1 å±‚çš„å¹³å‡å€¼ä¸º 14.5,ç¬¬ 2 å±‚çš„å¹³å‡å€¼ä¸º 11ã€‚å› æ­¤è¿”å› [3, 14.5, 11] ã€‚

**ç¤ºä¾‹ 2**ï¼š

![](./img/äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼-2.jpg)

> è¾“å…¥ï¼šroot = [3,9,20,15,7]
>
> è¾“å‡ºï¼š[3.00000,14.50000,11.00000]

::: code-group

```md [æ€è·¯]
çœ‹è§£ç­”
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function (root) {
  if (!root) return []
  let res = []
  let queue = [root]
  while (queue.length > 0) {
    // ç”¨æ¥æ§åˆ¶éå†å±‚æ•°å’Œç®—å¹³å‡å€¼çš„
    let level_size = queue.length // [!code ++]
    // æ±‚å’Œ
    let sum = 0 // [!code ++]
    for (let i = 0; i < level_size; i++) {
      const node = queue.shift()
      sum += node.val // [!code ++]
      // å·¦
      node.left && queue.push(node.left)
      // å³
      node.right && queue.push(node.right)
    }
    let n = sum / level_size // [!code ++]
    res.push(n) // [!code ++]
  }
  return res
}
```

:::

## 8. N å‰æ ‘çš„å±‚åºéå†

<LeetCodeLink url="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/" />

ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„å±‚åºéå†ã€‚ï¼ˆå³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†ï¼‰ã€‚

æ ‘çš„åºåˆ—åŒ–è¾“å…¥æ˜¯ç”¨å±‚åºéå†ï¼Œæ¯ç»„å­èŠ‚ç‚¹éƒ½ç”± null å€¼åˆ†éš”ï¼ˆå‚è§ç¤ºä¾‹ï¼‰ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/N%20å‰æ ‘çš„å±‚åºéå†-1.png)

> è¾“å…¥ï¼šroot = [1,null,3,2,4,null,5,6]
>
> è¾“å‡ºï¼š[[1],[3,2,4],[5,6]]

**ç¤ºä¾‹ 2**ï¼š

![](./img/N%20å‰æ ‘çš„å±‚åºéå†-2.png)

> è¾“å…¥ï¼šroot = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
>
> è¾“å‡ºï¼š[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜æ¯ä¸€å±‚å¯èƒ½æœ‰ 2 ä¸ªä»¥ä¸Š,æ‰€ä»¥ä¸å†ä½¿ç”¨ `node.left node.right`ï¼Œè€Œæ˜¯å»æ·»åŠ å®ƒçš„æ‰€æœ‰å­èŠ‚ç‚¹
```

```c [ä»£ç ]
/**
 * // Definition for a _Node.
 * function _Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */
/**
 * @param {_Node|null} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
  if (!root) return []
  let res = []
  let queue = [root]

  while (queue.length > 0) {
    let level_size = queue.length
    let level_res = []

    for (let i = 0; i < level_size; i++) {
      const node = queue.shift()
      level_res.push(node.val)

      // éå†å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼ˆä¸åªæ˜¯node.right / node.left)
      for (let item of node.children) { // [!code ++]
        queue.push(item) // [!code ++]
      } // [!code ++]
    }

    res.push(level_res)
  }

  return res
}
```

:::

## 9. åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼

<LeetCodeLink url="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/" />

ç»™å®šä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘ä¸­æ¯ä¸€å±‚çš„æœ€å¤§å€¼ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼.jpg)

> è¾“å…¥: root = [1,3,2,5,3,null,9]
>
> è¾“å‡º: [1,3,9]

**ç¤ºä¾‹ 2**ï¼š

> è¾“å…¥: root = [1,2,3]
>
> è¾“å‡º: [1,3]

::: code-group

```md [æ€è·¯]
è€æ€è·¯ï¼Œå»æ¯”è¾ƒå¤§å°å³å¯ï¼ˆéœ€è¦ç»™ max åˆå§‹åŒ–è®¾ç½®ä¸€ä¸ªæ— é™å°çš„å€¼`-Infinity` / `-Number.MAX_VALUE`ï¼‰
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var largestValues = function (root) {
  if (!root) return []
  let res = []
  let queue = [root]
  while (queue.length > 0) {
    const level_size = queue.length
    let max = -Number.MAX_VALUE // [!code ++]
    for (let i = 0; i < level_size; i++) {
      const node = queue.shift()
      max = Math.max(node.val, max) // [!code ++]
      // å­èŠ‚ç‚¹
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
    res.push(max) // [!code ++]
  }
  return res
}
```

:::

## 10. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

<LeetCodeLink url="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/" />

ç»™å®šä¸€ä¸ª å®Œç¾äºŒå‰æ ‘ ï¼Œå…¶æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½åœ¨åŒä¸€å±‚ï¼Œæ¯ä¸ªçˆ¶èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚äºŒå‰æ ‘å®šä¹‰å¦‚ä¸‹ï¼š

```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚

åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰ next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ-1.png)

> è¾“å…¥ï¼šroot = [1,2,3,4,5,6,7]
>
> è¾“å‡ºï¼š[1,#,2,3,#,4,5,6,7,#]
>
> è§£é‡Šï¼šç»™å®šäºŒå‰æ ‘å¦‚å›¾ A æ‰€ç¤ºï¼Œä½ çš„å‡½æ•°åº”è¯¥å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œä»¥æŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œå¦‚å›¾ B æ‰€ç¤ºã€‚åºåˆ—åŒ–çš„è¾“å‡ºæŒ‰å±‚åºéå†æ’åˆ—ï¼ŒåŒä¸€å±‚èŠ‚ç‚¹ç”± next æŒ‡é’ˆè¿æ¥ï¼Œ'#' æ ‡å¿—ç€æ¯ä¸€å±‚çš„ç»“æŸã€‚

**ç¤ºä¾‹ 2**:

> è¾“å…¥ï¼šroot = []
>
> è¾“å‡ºï¼š[]

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜çš„è¾“å‡ºå’Œä¹‹å‰çš„å®¹æ˜“è®©äººè¿·ç³Šï¼Œçœ‹ç­”é¢˜æ¨¡ç‰ˆï¼Œå‡½æ•°çš„è¿”å›å€¼æ˜¯ `_Node`ï¼Œä¹Ÿå°±æ˜¯äºŒå‰æ ‘èŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯æ•°ç»„ï¼Œ
æ‰€ä»¥éœ€è¦æ„å»ºäºŒå‰æ ‘çš„ `next` èŠ‚ç‚¹ã€‚
å¦‚ä½•å»æ‰¾åˆ°è¯¥èŠ‚ç‚¹å‘¢ï¼Ÿ`const node = queue.shift()` æ˜¯å½“å‰èŠ‚ç‚¹ï¼Œè€Œ `queue[0]` åˆ™æ˜¯ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ
åŸå› å¦‚ä¸‹ï¼šï¼ˆé˜Ÿåˆ—å¤´å‡ºï¼Œå‡ºæ¥åçš„é˜Ÿåˆ—çš„é¦–å…ƒç´ å°±æ˜¯ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼‰
å‡è®¾å½“å‰å±‚æœ‰èŠ‚ç‚¹ A, B, C
é˜Ÿåˆ—çŠ¶æ€ï¼š[A, B, C, ...ä¸‹ä¸€å±‚èŠ‚ç‚¹]
let node = queue.shift(); // å–å‡º A
æ­¤æ—¶é˜Ÿåˆ—å˜ä¸ºï¼š[B, C, ...ä¸‹ä¸€å±‚èŠ‚ç‚¹]
queue[0] å°±æ˜¯ Bï¼Œå³ A çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹
```

```c [ä»£ç ]
/**
 * // Definition for a _Node.
 * function _Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */
/**
 * @param {_Node} root
 * @return {_Node}
 */
var connect = function (root) {
  if (!root) return root
  let queue = [root]
  while (queue.length > 0) {
    let level_size = queue.length
    for (let i = 0; i < level_size; i++) {
      const node = queue.shift()
      // ifçš„ä½œç”¨ï¼šä¸ºäº†åŒºåˆ†å½“å‰å±‚çš„èŠ‚ç‚¹æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼š // [!code ++]
      // å½“ i < level_size - 1 æ—¶ï¼šå½“å‰èŠ‚ç‚¹ä¸æ˜¯å½“å‰å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œéœ€è¦è®¾ç½® next æŒ‡é’ˆ // [!code ++]
      // å½“ i === level_size - 1 æ—¶ï¼šå½“å‰èŠ‚ç‚¹æ˜¯å½“å‰å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸éœ€è¦è®¾ç½® next æŒ‡é’ˆï¼ˆé»˜è®¤ä¸º nullï¼‰ // [!code ++]
      if (i < level_size - 1) { // [!code ++]
        const next_node = queue[0] // [!code ++]
        node.next = next_node // [!code ++]
      } // [!code ++]
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return root // [!code ++]
}
```

:::

## 11. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

<LeetCodeLink url="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/" />

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚

æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚

**è¯´æ˜**ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

![](./img/äºŒå‰æ ‘çš„æœ€å°æ·±åº¦.jpg)

**ç¤ºä¾‹ 1**ï¼š

> è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
>
> è¾“å‡ºï¼š2

**ç¤ºä¾‹ 2**ï¼š

> è¾“å…¥ï¼šroot = [2,null,3,null,4,null,5,null,6]
>
> è¾“å‡ºï¼š5

::: code-group

```md [æ€è·¯]
è¯¥é¢˜éœ€è¦åˆ¤æ–­å½“å‰èŠ‚ç‚¹å¦‚ä½•ä¸ºç©ºï¼šå·¦å³å­æ ‘çš„èŠ‚ç‚¹éƒ½ä¸º null
```

```c [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
  if (!root) return 0
  let queue = [root]
  let minDeep = 0
  while (queue.length > 0) {
    const level_size = queue.length
    minDeep++
    for (let i = 0; i < level_size; i++) {
      const node = queue.shift()
      if (!node.left && !node.right) { // [!code ++]
        return minDeep // [!code ++]
      } // [!code ++]
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return minDeep
}
```

:::

## ğŸš€ â¬†ï¸ äºŒå‰æ ‘å±‚åºéå†

## 12. ç¿»è½¬äºŒå‰æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/invert-binary-tree/description/" />

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/ç¿»è½¬äºŒå‰æ ‘-1.jpg)

> è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9]
>
> è¾“å‡ºï¼š[4,7,2,9,6,3,1]

**ç¤ºä¾‹ 2**ï¼š

![](./img/ç¿»è½¬äºŒå‰æ ‘-2.jpg)

> è¾“å…¥ï¼šroot = [2,1,3]
>
> è¾“å‡ºï¼š[2,3,1]

**ç¤ºä¾‹ 3**ï¼š

> è¾“å…¥ï¼šroot = []
>
> è¾“å‡ºï¼š[]

::: code-group

```md [æ€è·¯]
äºŒå‰æ ‘çš„ç¿»è½¬ï¼Œå¯ä»¥ä»¥æ ¹èŠ‚ç‚¹ä¸ºåˆ†ç•Œè¿›è¡Œç¿»è½¬ï¼Œæƒ³è¦ç¿»è½¬å®ƒï¼Œå…¶å®å°±æŠŠæ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å³å­©å­äº¤æ¢ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚

å…³é”®åœ¨äºéå†é¡ºåºï¼Œå‰ä¸­ååºåº”è¯¥é€‰å“ªä¸€ç§éå†é¡ºåºï¼Ÿ
è¿™é“é¢˜ç›®ä½¿ç”¨å‰åºéå†å’Œååºéå†éƒ½å¯ä»¥ï¼Œå”¯ç‹¬ä¸­åºéå†ä¸æ–¹ä¾¿

**éå†çš„è¿‡ç¨‹ä¸­å»ç¿»è½¬æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å³å­©å­å°±å¯ä»¥è¾¾åˆ°æ•´ä½“ç¿»è½¬çš„æ•ˆæœ**ã€‚
```

```js [é€’å½’æ³•-å‰åºéå†]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
  if (!root) return null
  // ç”¨å˜é‡ä¿å­˜ä¸€ä¸‹èŠ‚ç‚¹
  let rightNode = root.right
  // äº¤æ¢èŠ‚ç‚¹
  root.right = invertTree(root.left)
  root.left = invertTree(rightNode)
  return root
}
```

```js [è¿­ä»£æ³•-å‰åºéå†]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
  if (!root) return null
  const stack = [root]
  while (stack.length > 0) {
    const node = stack.pop()
    if (node === null) {
      // è¿è¡Œåˆ°å½“å‰èŠ‚ç‚¹æ ‡è®°
      // è·å–å½“å‰èŠ‚ç‚¹
      const cur_node = stack.pop()
      // ç¿»è½¬
      const tmp = cur_node.left
      cur_node.left = cur_node.right
      cur_node.right = tmp
    } else {
      // å­˜èŠ‚ç‚¹ï¼Œå‰åºï¼šä¸­å·¦å³
      // å…¥æ ˆé¡ºåºï¼šå³å·¦ä¸­
      node.right && stack.push(node.right)
      node.left && stack.push(node.left)
      stack.push(node)
      stack.push(null)
    }
  }
  return root
}
```

```js [å±‚åºéå†]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
  if (!root) return null
  const queue = [root]
  while (queue.length > 0) {
    const level_size = queue.length
    for (let i = 0; i < level_size; i++) {
      const node = queue.shift()
      // äº¤æ¢å½“å‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘
      const temp = node.left
      node.left = node.right
      node.right = temp
      // å·¦å³èŠ‚ç‚¹
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return root
}
```

:::

## 13. å¯¹ç§°äºŒå‰æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/symmetric-tree/description/" />

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/å¯¹ç§°äºŒå‰æ ‘-1.png)

> è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3]
>
> è¾“å‡ºï¼štrue

**ç¤ºä¾‹ 2**ï¼š

![](./img/å¯¹ç§°äºŒå‰æ ‘-2.png)

> è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3]
>
> è¾“å‡ºï¼šfalse

::: code-group

```md [æ€è·¯]
å¯¹äºäºŒå‰æ ‘æ˜¯å¦å¯¹ç§°ï¼Œè¦æ¯”è¾ƒçš„æ˜¯**æ ¹èŠ‚ç‚¹**çš„å·¦å­æ ‘ä¸å³å­æ ‘æ˜¯ä¸æ˜¯ç›¸äº’ç¿»è½¬çš„ï¼Œ
**å…¶å®è¦æ¯”è¾ƒçš„æ˜¯ä¸¤ä¸ªæ ‘ï¼ˆè¿™ä¸¤ä¸ªæ ‘æ˜¯æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼‰**ï¼Œ
æ‰€ä»¥åœ¨é€’å½’éå†çš„è¿‡ç¨‹ä¸­ï¼Œä¹Ÿæ˜¯è¦**åŒæ—¶éå†ä¸¤æ£µæ ‘**ã€‚

**é€’å½’æ³•**ï¼š

- å‚æ•°ï¼šè¦æ¯”è¾ƒçš„æ˜¯ä¸¤ä¸ªæ ‘ï¼Œå‚æ•°è‡ªç„¶ä¹Ÿæ˜¯å·¦å­æ ‘èŠ‚ç‚¹å’Œå³å­æ ‘èŠ‚ç‚¹ã€‚
- ç»ˆæ­¢æ¡ä»¶ï¼šè¦æ¯”è¾ƒä¸¤ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸ä¸ç›¸åŒï¼Œé¦–å…ˆè¦æŠŠä¸¤ä¸ªèŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µå¼„æ¸…æ¥šï¼å¦åˆ™åé¢æ¯”è¾ƒæ•°å€¼çš„æ—¶å€™å°±ä¼šæ“ä½œç©ºæŒ‡é’ˆäº†ã€‚
  - èŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µæœ‰ï¼šï¼ˆæ³¨æ„æˆ‘ä»¬æ¯”è¾ƒçš„å…¶å®ä¸æ˜¯å·¦å­©å­å’Œå³å­©å­ï¼Œæ‰€ä»¥å¦‚ä¸‹ç§°ä¹‹ä¸ºå·¦èŠ‚ç‚¹å³èŠ‚ç‚¹ï¼‰
    å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œå³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œä¸å¯¹ç§°ï¼Œreturn false
    å·¦ä¸ä¸ºç©ºï¼Œå³ä¸ºç©ºï¼Œä¸å¯¹ç§° return false
    å·¦å³éƒ½ä¸ºç©ºï¼Œå¯¹ç§°ï¼Œè¿”å› trueï¼ˆå½“å‰èŠ‚ç‚¹ï¼Œå¯ä»¥è·³è¿‡åˆ°ä¸‹ä¸€æ¬¡å¾ªç¯ï¼‰
  - æ­¤æ—¶å·²ç»æ’é™¤æ‰äº†èŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µï¼Œé‚£ä¹ˆå‰©ä¸‹çš„å°±æ˜¯å·¦å³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼š
    å·¦å³éƒ½ä¸ä¸ºç©ºï¼Œæ¯”è¾ƒèŠ‚ç‚¹æ•°å€¼ï¼Œä¸ç›¸åŒå°± return false
- å•å±‚é€’å½’çš„é€»è¾‘ï¼šå·¦å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œä¸”æ•°å€¼ç›¸åŒçš„æƒ…å†µã€‚
  - æ¯”è¾ƒäºŒå‰æ ‘å¤–ä¾§æ˜¯å¦å¯¹ç§°ï¼šä¼ å…¥çš„æ˜¯å·¦èŠ‚ç‚¹çš„å·¦å­©å­ï¼Œå³èŠ‚ç‚¹çš„å³å­©å­ã€‚
  - æ¯”è¾ƒå†…ä¾§æ˜¯å¦å¯¹ç§°ï¼Œä¼ å…¥å·¦èŠ‚ç‚¹çš„å³å­©å­ï¼Œå³èŠ‚ç‚¹çš„å·¦å­©å­ã€‚
  - å¦‚æœå·¦å³éƒ½å¯¹ç§°å°±è¿”å› true ï¼Œæœ‰ä¸€ä¾§ä¸å¯¹ç§°å°±è¿”å› falseã€‚

**è¿­ä»£æ³•**ï¼š

è¿™é‡Œçš„è¿­ä»£æ³•å¯ä¸æ˜¯å‰ä¸­ååºçš„è¿­ä»£å†™æ³•ï¼Œæœ¬é¢˜çš„æœ¬è´¨æ˜¯åˆ¤æ–­ä¸¤ä¸ªæ ‘æ˜¯å¦æ˜¯ç›¸äº’ç¿»è½¬çš„ï¼Œå…¶å®å·²ç»ä¸æ˜¯æ‰€è°“äºŒå‰æ ‘éå†çš„å‰ä¸­ååºçš„å…³ç³»äº†ã€‚
è¿™é‡Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨é˜Ÿåˆ—æ¥æ¯”è¾ƒä¸¤ä¸ªæ ‘ï¼ˆæ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼‰æ˜¯å¦ç›¸äº’ç¿»è½¬ï¼Œï¼ˆæ³¨æ„è¿™ä¸æ˜¯å±‚åºéå†ï¼‰
é€šè¿‡é˜Ÿåˆ—æ¥åˆ¤æ–­æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘çš„å†…ä¾§å’Œå¤–ä¾§æ˜¯å¦ç›¸ç­‰ï¼ŒåŠ¨ç”»å¦‚ä¸‹ï¼š
```

```js [é€’å½’æ³•]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
  if (!root) return false
  return diffNode(root.left, root.right)
}

function diffNode(left, right) {
  if ((left === null && right !== null) || (left !== null && right === null)) {
    // leftã€rightåªæœ‰ä¸€è€…ä¸ºnullï¼Œç›´æ¥false
    return false
  } else if (left === null && right === null) {
    // ç»“æŸå½“å‰é€’å½’å‡½æ•°
    return true
  } else if (left.val !== right.val) {
    // èŠ‚ç‚¹å€¼ä¸ç›¸ç­‰
    return false
  }
  // æ’é™¤å½“å‰èŠ‚ç‚¹å¾ˆæ˜æ˜¾ä¸å¯¹ç§°çš„æƒ…å†µ
  // å»è€ƒè™‘å·¦æ ‘çš„å¤–ä¾§æ˜¯å¦ç­‰äºå³æ ‘çš„å¤–ä¾§
  const outSide = diffNode(left.left, right.right)
  // è€ƒè™‘å·¦æ ‘å†…ä¾§æ˜¯å¦ç­‰äºå³æ ‘å†…ä¾§
  const inSide = diffNode(left.right, right.left)
  // åªæœ‰å½“outSideå’ŒinSideä¸¤ç§æƒ…å†µéƒ½æ»¡è¶³ï¼Œæ ‘æ‰æ˜¯å¯¹ç§°çš„
  return outSide && inSide
}
```

```js [è¿­ä»£æ³•]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
  if (!root) return false
  // åŒæ—¶å»æ“ä½œä¸¤é¢—æ ‘ï¼ˆå·¦å³æ ‘ï¼‰
  const queue = [root.left, root.right]
  while (queue.length > 0) {
    // å’Œä¸Šé¢åˆå§‹åŒ–çš„é¡ºåºä¸€è‡´å°±è¡Œ
    const leftNode = queue.shift() // å·¦èŠ‚ç‚¹
    const rightNode = queue.shift() // å³èŠ‚ç‚¹
    // ä¸‹é¢çš„if elseåˆ¤æ–­åªæ˜¯åˆ¤æ–­ä¸¤ä¸ªæ•°çš„èŠ‚ç‚¹æ˜¯å¦æ»¡è¶³æ¡ä»¶
    if (
      (leftNode === null && rightNode !== null) ||
      (leftNode !== null && rightNode === null)
    ) {
      // èŠ‚ç‚¹ä¸ç›¸åŒï¼Œç›´æ¥false
      return false
    } else if (leftNode === null && rightNode === null) {
      // èŠ‚ç‚¹ç›¸åŒï¼Œç»§ç»­æ¯”è¾ƒï¼ˆå¯èƒ½æ˜¯æŸä¸ªåˆ†æ”¯çš„èŠ‚ç‚¹ï¼Œä¸ä¸€å®šåˆ°æœ«å°¾äº†ï¼‰
      continue
    } else if (leftNode.val !== rightNode.val) {
      return false
    }
    // ifè¿‡åè¡¨ç¤ºå½“å‰èŠ‚ç‚¹æ»¡è¶³æ¡ä»¶äº†ï¼Œå°†å­èŠ‚ç‚¹ç»§ç»­æ”¾å…¥é˜Ÿåˆ—æ¯”è¾ƒ
    // å°†å·¦æ ‘å¤–ä¾§å’Œå³æ ‘å¤–ä¾§èŠ‚ç‚¹åŠ å…¥
    queue.push(leftNode.left)
    queue.push(rightNode.right)
    // å°†å·¦æ ‘å†…ä¾§å’Œå³æ ‘å†…ä¾§åŠ å…¥
    queue.push(leftNode.right)
    queue.push(rightNode.left)
  }
  return true
}
```

:::

![](./img/101.å¯¹ç§°äºŒå‰æ ‘.gif)

## 14. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°

<LeetCodeLink url="https://leetcode.cn/problems/count-complete-tree-nodes/description/" />

ç»™ä½ ä¸€æ£µ **å®Œå…¨äºŒå‰æ ‘** çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°.jpg)

> è¾“å…¥ï¼šroot = [1,2,3,4,5,6]
>
> è¾“å‡ºï¼š6

**ç¤ºä¾‹ 2**ï¼š

> è¾“å…¥ï¼šroot = []
>
> è¾“å‡ºï¼š0

**ç¤ºä¾‹ 3**ï¼š

> è¾“å…¥ï¼šroot = [1]
>
> è¾“å‡ºï¼š1

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜çš„è§£æ³•å°±æ˜¯æŠŠå®ƒå½“ä½œæ™®é€šäºŒå‰æ ‘ï¼Œå‰ä¸­å/å±‚åºè®¡ç®—å‡ºèŠ‚ç‚¹æ€»æ•°å°±è¡Œ
```

```js [ä»£ç : å±‚åºéå†]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function (root) {
  if (!root) return 0
  const queue = [root]
  let nums = 0
  while (queue.length > 0) {
    const level_size = queue.length
    for (let i = 0; i < level_size; i++) {
      const node = queue.shift()
      nums++
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return nums
}
```

:::

## 15. å¹³è¡¡äºŒå‰æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/balanced-binary-tree/description/" />

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚

> å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡è¯¥æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„**é«˜åº¦ç›¸å·®**ä¸è¶…è¿‡ 1ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/å¹³è¡¡äºŒå‰æ ‘-1.jpg)

> è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
>
> è¾“å‡ºï¼štrue

**ç¤ºä¾‹ 2**ï¼š

![](./img/å¹³è¡¡äºŒå‰æ ‘-2.jpg)

> è¾“å…¥ï¼šroot = [1,2,2,3,3,null,null,4,4]
>
> è¾“å‡ºï¼šfalse

**ç¤ºä¾‹ 3**ï¼š

> è¾“å…¥ï¼šroot = []
>
> è¾“å‡ºï¼štrue

::: code-group

```txt [æ€è·¯]
â€œå¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡è¯¥æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦ç›¸å·®ä¸è¶…è¿‡ 1ã€‚â€
è¿™é‡Œå®šä¹‰çš„é«˜åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦é‡‡ç”¨ååºéå†æ¥è§£å†³ã€‚
å› ä¸ºååºéå†æ˜¯å·¦å³ä¸­ï¼Œè®¡ç®—å®Œå·¦å³å­æ ‘ï¼Œæœ€åå¤„ç†å½“å‰èŠ‚ç‚¹ï¼ˆå¯ä»¥å»çœ‹ã€äºŒå‰æ ‘åŸºç¡€çŸ¥è¯†-äºŒå‰æ ‘çš„é«˜åº¦å’Œæ·±åº¦ã€‘éƒ¨åˆ†ï¼‰

é€’å½’æ³•ã€è¿­ä»£æ³•æ ¸å¿ƒï¼šå½“å‰å·¦å­æ ‘å³å­æ ‘é«˜åº¦ç›¸å·®å¤§äº 1 å°±è¿”å›-1

**é€’å½’**ï¼š
æ­¤æ—¶æ—¢ç„¶è¦æ±‚æ¯”è¾ƒé«˜åº¦ï¼Œå¿…ç„¶æ˜¯è¦ååºéå†ã€‚

**è¿­ä»£**ï¼š
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å±‚åºéå†æ¥æ±‚æ·±åº¦ï¼Œä½†æ˜¯å°±ä¸èƒ½ç›´æ¥ç”¨å±‚åºéå†æ¥æ±‚é«˜åº¦äº†ï¼Œè¿™å°±ä½“ç°å‡ºæ±‚é«˜åº¦å’Œæ±‚æ·±åº¦çš„ä¸åŒã€‚

å¯ä»¥å…ˆå®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œä¸“é—¨ç”¨æ¥æ±‚é«˜åº¦ï¼Œ
è¿™ä¸ªå‡½æ•°ï¼ˆgetHeightï¼‰é€šè¿‡æ ˆæ¨¡æ‹Ÿçš„ååºéå†æ‰¾æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„é«˜åº¦ï¼ˆå…¶å®æ˜¯é€šè¿‡æ±‚ä¼ å…¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦æ¥æ±‚çš„é«˜åº¦ï¼‰ï¼›
ç„¶åå†ç”¨æ ˆæ¥æ¨¡æ‹Ÿååºéå†ï¼Œéå†æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼Œå†å»åˆ¤æ–­å·¦å³å­©å­çš„é«˜åº¦æ˜¯å¦ç¬¦åˆ

åœ¨getHeightå‡½æ•°ï¼Œå½“node===nullçš„æ—¶å€™ï¼Œä¼šæ‰§è¡Œdeepth--çš„æ“ä½œï¼Œè¿™ä¸ªæ“ä½œçš„ç›®çš„ï¼š
è¡¨ç¤ºæˆ‘ä»¬å·²ç»å¤„ç†å®Œå½“å‰èŠ‚ç‚¹åŠå…¶å­æ ‘ï¼Œéœ€è¦é€€å›ä¸Šä¸€å±‚ã€‚ä¾‹å¦‚ï¼š
    1
   / \
  2   3
 /
4
éå†è¿‡ç¨‹ä¸­çš„ depth å˜åŒ–å¦‚ä¸‹ï¼š
è®¿é—®èŠ‚ç‚¹ 1ï¼šdepth = 1
è®¿é—®èŠ‚ç‚¹ 2ï¼šdepth = 2
è®¿é—®èŠ‚ç‚¹ 4ï¼šdepth = 3
èŠ‚ç‚¹ 4 æ— å­èŠ‚ç‚¹ï¼Œå¤„ç†å®Œæ¯•å depth--ï¼Œdepth = 2
å›åˆ°èŠ‚ç‚¹ 2ï¼Œå¤„ç†å®Œæ¯•å depth--ï¼Œdepth = 1
è®¿é—®èŠ‚ç‚¹ 3ï¼šdepth = 2
èŠ‚ç‚¹ 3 æ— å­èŠ‚ç‚¹ï¼Œå¤„ç†å®Œæ¯•å depth--ï¼Œdepth = 1
å›åˆ°èŠ‚ç‚¹ 1ï¼Œå¤„ç†å®Œæ¯•å depth--ï¼Œdepth = 0
æœ€ç»ˆè¿”å›æœ€å¤§æ·±åº¦ 3ã€‚
```

```js [é€’å½’æ³•]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
  // åœ¨ä¸Šé¢çš„åˆ¤æ–­æ˜¯ä¸å¹³è¡¡å°±æ˜¯-1ï¼Œåªè¦ä¸æ˜¯-1å°±æ˜¯å¹³è¡¡äºŒå‰æ ‘
  return !(getDepth(root) === -1)
}

var getDepth = function (node) {
  // ç»ˆæ­¢æ¡ä»¶ï¼šç©ºèŠ‚ç‚¹é«˜åº¦ä¸º0
  if (node === null) return 0

  if (!node.left && !node.right) {
    return 1
  }

  // è·å–å·¦å³å­æ ‘é«˜åº¦
  let leftDepth = getDepth(node.left)
  // æå‰å‘ç°ä¸å¹³è¡¡ï¼šå½“å·¦å­æ ‘å·²ç»æ˜¯ä¸å¹³è¡¡çš„ï¼ˆè¿”å›-1ï¼‰ï¼Œåˆ™æ•´ä¸ªæ ‘è‚¯å®šä¸å¹³è¡¡
  if (leftDepth === -1) {
    return -1
  }
  let rightDepth = getDepth(node.right)
  if (rightDepth === -1) {
    return -1
  }

  // å·¦å³å­æ ‘é«˜åº¦å·®çš„ç»å¯¹å€¼ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºå¹³è¡¡äºŒå‰æ ‘
  if (Math.abs(leftDepth - rightDepth) > 1) {
    return -1 // ä¸å¹³è¡¡è¿”å›-1
  } else {
    // å¹³è¡¡åˆ™è¿”å›å½“å‰èŠ‚ç‚¹é«˜åº¦ï¼ˆé«˜åº¦æ˜¯èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹è·ç¦»ï¼‰
    return 1 + Math.max(leftDepth, rightDepth)
  }
}
```

```js [è¿­ä»£æ³•]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
  if (!root) return true
  const stack = [root]
  while (stack.length > 0) {
    const node = stack.pop()
    if (Math.abs(getHeight(node.left) - getHeight(node.right)) > 1) {
      return false
    }
    // æ™®é€šçš„å‰åºéå†ï¼Œä½†æ˜¯è¿™é‡Œçš„leftã€rightå¯ä»¥ä¸ç®¡é¡ºåºï¼Œï¼ˆä¸æ˜¯ç»Ÿä¸€è¿­ä»£æ³•æ¨¡ç‰ˆï¼‰
    node.left && stack.push(node.left)
    node.right && stack.push(node.right)
  }
  return true
}

function getHeight(node) {
  if (!node) return 0
  let stack = [node]
  // æ ‘çš„é«˜åº¦
  let res = 0
  // å½“å‰èŠ‚ç‚¹çš„é«˜åº¦
  let depth = 0
  while (stack.length > 0) {
    const node = stack.pop()
    if (node === null) {
      // é‡åˆ°æ ‡è®°å…ƒç´ ï¼Œåˆ™å¼¹å‡ºæ ‡è®°å…ƒç´ ï¼ˆå¯ä»¥ä¸ç”¨å˜é‡æ¥å—å½“å‰å…ƒç´ ï¼‰
      const cur_node = stack.pop()
      // è¡¨ç¤ºæˆ‘ä»¬å·²ç»å¤„ç†å®Œå½“å‰èŠ‚ç‚¹åŠå…¶å­æ ‘ï¼Œéœ€è¦é€€å›ä¸Šä¸€å±‚
      /**
       * å› ä¸ºå½“å‰æ˜¯ååºéå†ï¼Œå…¥æ ˆé¡ºåºï¼šä¸­å³å·¦
       * å½“æ‰§è¡Œåˆ°èŠ‚ç‚¹æ—¶ï¼Œå·²ç»å¤„ç†å®Œå½“å‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼Œæ‰€ä»¥éœ€è¦é€€å›ä¸Šä¸€å±‚
       * åœ¨éå†å­æ ‘çš„æ—¶å€™ï¼Œdepth++äº†ï¼Œæ‰€ä»¥æ­¤æ—¶éœ€è¦--
       * */
      depth--
    } else {
      // ååºéå†ï¼šå·¦å³ä¸­
      // å…¥æ ˆé¡ºåºï¼šä¸­å³å·¦
      // ä¸­
      stack.push(node)
      stack.push(null)
      // å³
      node.right && stack.push(node.right)
      // å·¦
      node.left && stack.push(node.left)
      // æœ€åpushåˆ°æ ˆçš„å…ƒç´ æ˜¯å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥åˆ°ä¸‹ä¸€å±‚äº†ï¼Œéœ€è¦++
      depth++
    }
    // é€‰å¤§çš„
    res = Math.max(res, depth)
  }
  return res
}
```

:::

## 16. è·¯å¾„æ€»å’Œ

<LeetCodeLink url="https://leetcode.cn/problems/path-sum/description/" />

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° targetSum ã€‚åˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ targetSum ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚

å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/è·¯å¾„æ€»å’Œ-1.jpg)

> è¾“å…¥ï¼šroot = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
>
> è¾“å‡ºï¼štrue
>
> è§£é‡Šï¼šç­‰äºç›®æ ‡å’Œçš„æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹è·¯å¾„å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚

**ç¤ºä¾‹ 2**ï¼š

![](./img/è·¯å¾„æ€»å’Œ-2.jpg)

> è¾“å…¥ï¼šroot = [1,2,3], targetSum = 5
>
> è¾“å‡ºï¼šfalse
>
> è§£é‡Šï¼šæ ‘ä¸­å­˜åœ¨ä¸¤æ¡æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼š
>
> (1 --> 2): å’Œä¸º 3
>
> (1 --> 3): å’Œä¸º 4
>
> ä¸å­˜åœ¨ sum = 5 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚

**ç¤ºä¾‹ 3**ï¼š

> è¾“å…¥ï¼šroot = [], targetSum = 0
>
> è¾“å‡ºï¼šfalse
>
> è§£é‡Šï¼šç”±äºæ ‘æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥ä¸å­˜åœ¨æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚

::: code-group

```md [æ€è·¯]
é¢˜æ„ï¼šä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œä»»æ„ä¸€æ¡è·¯å¾„å’Œç­‰äº targetSum å³å¯

**é€’å½’æ€è·¯**ï¼š

1ã€ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼š
traversal(node, sum) è¿”å›å¸ƒå°”å€¼ï¼ˆsum å¯ä»¥åˆå§‹åŒ–ç­‰äº targetSumï¼Œç„¶åå»ä¾æ¬¡ç›¸å‡ï¼‰ï¼Œå¦‚æœå‡åˆ°å¶å­èŠ‚ç‚¹ä¸º 0ï¼Œåˆ™ç¬¦åˆæ¡ä»¶

2ã€ç¡®å®šé€’å½’ç»ˆæ­¢æ¡ä»¶ï¼š
å½“é‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œåˆ¤æ–­å½“å‰è·¯å¾„æ˜¯å¦æ˜¯ç¬¦åˆæ¡ä»¶çš„ï¼š
`if (node.left == null && node.right == null && sum == 0)` å°±ç¬¦åˆæ¡ä»¶ï¼Œreturn true
ä¸ç¬¦åˆæ¡ä»¶çš„è·¯å¾„ï¼š
`if (node.left == null && node.right == null && sum != 0)`ï¼šåˆ°å¶å­èŠ‚ç‚¹ä¸ä¸º 0ï¼Œè¯æ˜ä¸ç¬¦åˆæ¡ä»¶

3ã€ç¡®å®šå•å±‚é€’å½’é€»è¾‘ï¼š
ä¸Šé¢çš„åˆ¤æ–­ node çš„å·¦å³å­æ ‘å¯èƒ½ä¸ºç©ºï¼Œä¸‹é¢è¿›è¡Œåˆ¤æ–­ï¼š
å¦‚æœå·¦å­æ ‘ä¸ä¸ºç©ºï¼Œé‚£å°± count å‡å» node.left.valï¼Œè½¬åˆ°å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹è¿›è¡Œé€’å½’
if (node.left != null) {
count -= node.left.val;
traversal(node.left, count)
}
ç”±äº traversal å‡½æ•°æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œè¿”å›å¸ƒå°”å€¼æ‰€ä»¥éœ€è¦æ”¾åœ¨ if ä¸­è¿›è¡Œåˆ¤æ–­ï¼Œä¹Ÿå°±å˜æˆäº†ï¼š
`if (node.left != null && traversal(node.left, count - node.left.val)) return true`ï¼Œ
ä¸ºä»€ä¹ˆåˆ¤æ–­åå¯ä»¥ç›´æ¥ return true å‘¢ï¼Ÿ
æ˜¯å› ä¸ºåé¢çš„åˆ¤æ–­ traversal çš„è¿”å›å€¼å·²ç»æ˜¯ trueï¼Œè¡¨ç¤ºä¸‹é¢çš„æŸä¸ªèŠ‚ç‚¹å·²ç»æ»¡è¶³æ¡ä»¶äº†ï¼Œåªæ˜¯å›æº¯åˆ°å½“å‰èŠ‚ç‚¹ï¼Œä¾æ¬¡å‘ä¸Šï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ï¼›
å³èŠ‚ç‚¹ä¹Ÿæ˜¯å¦‚æ­¤ã€‚
å¦‚æœä¸Šé¢åˆ¤æ–­éƒ½ä¸æ»¡è¶³ï¼Œåˆ™ return false

åœ¨ä¸Šé¢ if çš„é€’å½’ä¸­`traversal(node.left, count - node.left.val)`ï¼Œç”±äºæ²¡æœ‰æ”¹å˜ count çš„å®é™…å€¼ï¼Œæ‰€ä»¥åœ¨å›æº¯çš„æ—¶å€™ä¸éœ€è¦æŠŠ count æ¢å¤åˆ°åŸæ¥çš„å€¼ï¼ˆä¸ç”¨æŠŠå‡æ‰çš„åŠ å›æ¥ï¼‰
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function (root, targetSum) {
  if (!root) return false
  return traversal(root, targetSum - root.val)
}

function traversal(node, count) {
  if (!node.left && !node.right && count === 0) {
    // æŸä¸ªèŠ‚ç‚¹æ»¡è¶³æ¡ä»¶ï¼Œç»“æŸé€’å½’ï¼ˆå¦‚æœå½“å‰æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç›¸å½“äºé€’å½’å›æº¯ï¼Œä¸Šé¢çš„ä¾æ¬¡ä¸ºtrueï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ï¼‰
    return true
  }
  if (!node.left && !node.right && count !== 0) {
    // æ‰¾åˆ°å¶å­èŠ‚ç‚¹ä¹Ÿä¸æ»¡è¶³æ¡ä»¶ï¼Œç»“æŸé€’å½’
    return false
  }

  // å•å±‚é€»è¾‘
  // èŠ‚ç‚¹ä¸ºç©ºï¼Œè¿›è¡Œé€’å½’
  // ä¸ºä»€ä¹ˆæ˜¯count - node.left.valï¼Œè€Œä¸æ˜¯count - node.valï¼Ÿ
  // å› ä¸ºå½“å‰traversaléå†çš„èŠ‚ç‚¹æ˜¯node.leftï¼Œå‚æ•°2æŒ‡çš„æ˜¯æ ¹èŠ‚ç‚¹ç»è¿‡å½“å‰èŠ‚ç‚¹è¿˜éœ€è¦å¤šå°‘å€¼ï¼Œæ‰€ä»¥éœ€è¦å‡å»node.left.val
  if (node.left && traversal(node.left, count - node.left.val)) {
    // æ‰§è¡Œåˆ°è¿™è¡Œï¼Œè¡¨ç¤ºifåˆ¤æ–­ä¸­çš„traversalä¸ºtrueï¼Œåªè¦traversalä¸ºtrueï¼Œå°±å›æº¯ç»“æœ
    return true
  }
  if (node.right && traversal(node.right, count - node.right.val)) {
    return true
  }

  // ä¸Šé¢æƒ…å†µä¸æ»¡è¶³å°±æ˜¯è¿”å›false
  return false
}
```

:::

## 17. è·¯å¾„æ€»å’Œ II

<LeetCodeLink url="https://leetcode.cn/problems/path-sum-ii/description/" />

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ targetSum ï¼Œæ‰¾å‡ºæ‰€æœ‰ ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚

å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/è·¯å¾„æ€»å’Œ%20II-1.jpg)

> è¾“å…¥ï¼šroot = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
>
> è¾“å‡ºï¼š[[5,4,11,2],[5,8,4,5]]

**ç¤ºä¾‹ 2**ï¼š

![](./img/è·¯å¾„æ€»å’Œ%20II-2.jpg)

> è¾“å…¥ï¼šroot = [1,2,3], targetSum = 5
>
> è¾“å‡ºï¼š[]

**ç¤ºä¾‹ 3**ï¼š

> è¾“å…¥ï¼šroot = [1,2], targetSum = 0
>
> è¾“å‡ºï¼š[]

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜æ˜¯éå†æ•´ä¸ªæ ‘ï¼Œæ‰¾åˆ°æ‰€æœ‰è·¯å¾„ï¼Œæ‰€ä»¥é€’å½’å‡½æ•°ä¸è¦è¿”å›å€¼ï¼
æ³¨æ„éœ€è¦å›æº¯ï¼Œå½“é€’å½’å®Œæˆåï¼Œè¦å›æº¯åˆ°ä¸Šä¸€å±‚ï¼Œå°†æœ«å°¾èŠ‚ç‚¹ï¼ˆä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ï¼‰ä»è·¯å¾„ä¸­åˆ é™¤
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function (root, targetSum) {
  if (!root) return []
  // å­˜æ”¾ç»“æœçš„äºŒç»´æ•°ç»„
  const res = []
  traversal(root, targetSum - root.val, [root.val], res)
  return res
}

// pathä¸ºä¸€æ¡ç¬¦åˆæ¡ä»¶çš„è·¯å¾„ç»“æœ
function traversal(node, count, path, res) {
  if (!node.left && !node.right && count === 0) {
    // æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„è·¯å¾„
    // ä¸èƒ½ç›´æ¥res.push(path)ï¼Œè¦æ·±æ‹·è´
    res.push([...path])
    return
  }
  if (!node.left && !node.right && count !== 0) {
    // ä¸ç¬¦åˆæ¡ä»¶
    return
  }
  // å•æ¬¡é€’å½’æ“ä½œ
  if (node.left) {
    // å­˜æ”¾ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„è·¯å¾„
    path.push(node.left.val)
    traversal(node.left, count - node.left.val, path, res)
    // å›æº¯ï¼ˆæ‰§è¡Œtraversalï¼Œè¡¨ç¤ºå­èŠ‚ç‚¹å·²ç»æ‰§è¡Œå®Œæˆäº†ï¼Œæ‰€ä»¥éœ€è¦æŠŠpushè¿›å»çš„å€¼ç»™å¼¹å‡ºï¼‰
    path.pop()
  }

  if (node.right) {
    path.push(node.right.val)
    traversal(node.right, count - node.right.val, path, res)
    path.pop()
  }

  return
}
```

:::

## 18. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" />

ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `inorder` å’Œ `postorder` ï¼Œå…¶ä¸­ `inorder` æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ `postorder` æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— äºŒå‰æ ‘ ã€‚

æ³¨æ„ï¼š

- `inorder` å’Œ `postorder` éƒ½ç”± ä¸åŒ çš„å€¼ç»„æˆ
- `postorder` ä¸­æ¯ä¸€ä¸ªå€¼éƒ½åœ¨ `inorder` ä¸­
- `inorder` ä¿è¯æ˜¯æ ‘çš„ä¸­åºéå†
- `postorder` ä¿è¯æ˜¯æ ‘çš„ååºéå†

**ç¤ºä¾‹ 1**:

![](./img/ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘.jpg)

> è¾“å…¥ï¼šinorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
>
> è¾“å‡ºï¼š[3,9,20,null,null,15,7]

**ç¤ºä¾‹ 2**:

> è¾“å…¥ï¼šinorder = [-1], postorder = [-1]
>
> è¾“å‡ºï¼š[-1]

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜æˆ‘ä»¬éœ€è¦å…ˆä»ååºæ•°ç»„å¼€å§‹ï¼Œæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ä¸ºæ ¹èŠ‚ç‚¹ï¼Œ
é€šè¿‡è¿™ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå°†ä¸­åºæ•°ç»„åˆ†ä¸ºä¸¤ä¸ªæ•°ç»„ï¼Œå·¦ä¾§ä¸ºæ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼Œå³ä¾§ä¸ºæ ¹èŠ‚ç‚¹çš„å³å­æ ‘ï¼›
å°†å·¦å­æ ‘æ•°ç»„çš„æœ€å³ä¾§å…ƒç´ å»åˆ†å‰²ååºæ•°ç»„çš„å‰©ä½™æ•°ç»„ï¼Œç„¶ååˆ†å¼€çš„æ•°ç»„ä¹Ÿé€šè¿‡æœ«å°¾å…ƒç´ æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œä»¥æ­¤ç±»æ¨ï¼ˆæ€è·¯å¦‚ä¸‹ï¼‰

**é€’å½’å®ç°**ï¼š
ç¬¬ä¸€æ­¥ï¼šå¦‚æœæ•°ç»„å¤§å°ä¸ºé›¶çš„è¯ï¼Œè¯´æ˜æ˜¯ç©ºèŠ‚ç‚¹äº†ï¼ˆåªç”¨åˆ¤æ–­ååºä¸€ä¸ªå³å¯ï¼‰
ç¬¬äºŒæ­¥ï¼šå¦‚æœä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå–ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºèŠ‚ç‚¹å…ƒç´ 
ç¬¬ä¸‰æ­¥ï¼šæ‰¾åˆ°ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ åœ¨ä¸­åºæ•°ç»„çš„ä½ç½®ï¼Œä½œä¸ºåˆ‡å‰²ç‚¹
ç¬¬å››æ­¥ï¼šåˆ‡å‰²ä¸­åºæ•°ç»„ï¼Œåˆ‡æˆä¸­åºå·¦æ•°ç»„å’Œä¸­åºå³æ•°ç»„ï¼ˆé¡ºåºåˆ«æåäº†ï¼Œä¸€å®šæ˜¯å…ˆåˆ‡ä¸­åºæ•°ç»„ï¼‰

ä¸ºä»€ä¹ˆå…ˆåˆ‡ä¸­åºæ•°ç»„ï¼Ÿ

- åœ¨æ„é€ äºŒå‰æ ‘çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“æ ¹èŠ‚ç‚¹åœ¨ä¸­åºéå†ä¸­çš„ä½ç½®ï¼Œè¿™æ ·æ‰èƒ½ç¡®å®šï¼š
  - å·¦å­æ ‘æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹
  - å³å­æ ‘æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹
  - è¿›è€Œæ‰èƒ½æ­£ç¡®åˆ‡å‰²ååºæ•°ç»„

ç¬¬äº”æ­¥ï¼šåˆ‡å‰²ååºæ•°ç»„ï¼Œåˆ‡æˆååºå·¦æ•°ç»„å’Œååºå³æ•°ç»„
ç¬¬å…­æ­¥ï¼šé€’å½’å¤„ç†å·¦åŒºé—´å’Œå³åŒºé—´
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function (inorder, postorder) {
  // 1. ç©ºèŠ‚ç‚¹
  if (!postorder.length) return null

  // 2. æ ¹èŠ‚ç‚¹ä¸ºååºæ•°ç»„æœ«å°¾èŠ‚ç‚¹
  const rootVal = postorder[postorder.length - 1]
  const root = new TreeNode(rootVal)

  // 3. æ ¹èŠ‚ç‚¹åœ¨ä¸­åºæ•°ç»„ä¸­çš„ä¸‹æ ‡
  const in_root_index = inorder.indexOf(rootVal)

  // 4. åˆ‡å‰²ä¸­åºæ•°ç»„
  const leftInorder = inorder.slice(0, in_root_index)
  const rightInorder = inorder.slice(in_root_index + 1)

  // 5. æ ¹æ®ä¸­åºåˆ‡å‰²ç»“æœï¼Œåˆ‡å‰²ååºæ•°ç»„ï¼ˆååºè¦å€ŸåŠ©ä¸­åºæ•°ç»„çš„é•¿åº¦è¿›è¡Œåˆ‡å‰²ï¼Œæ‰€ä»¥è¦å…ˆåˆ‡å‰²ä¸­åºï¼‰
  const leftPostorder = postorder.slice(0, leftInorder.length)
  const rightPostorder = postorder.slice(
    leftInorder.length,
    postorder.length - 1
  )

  // 6. é€’å½’æ„å»ºå·¦å³å­æ ‘
  root.left = buildTree(leftInorder, leftPostorder)
  root.right = buildTree(rightInorder, rightPostorder)

  return root
}
```

:::

| æ€è·¯                           | è¿‡ç¨‹                             |
| ------------------------------ | -------------------------------- |
| ![](./img/æ„é€ äºŒå‰æ ‘-demo.png) | ![](./img/æ„é€ äºŒå‰æ ‘-demo-2.png) |

## 19. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" />

ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ preorder å’Œ inorder ï¼Œå…¶ä¸­ preorder æ˜¯äºŒå‰æ ‘çš„å…ˆåºéå†ï¼Œ inorder æ˜¯åŒä¸€æ£µæ ‘çš„ä¸­åºéå†ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

::: code-group

```md [æ€è·¯]
å’Œä¸Šä¸€é¢˜æ€è·¯ä¸€æ ·ï¼Œéƒ½æ˜¯å€ŸåŠ©å‰åº/ååºæ•°ç»„ï¼Œæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œéœ€è¦æ³¨æ„åˆ‡å‰²çš„ä½ç½®
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function (preorder, inorder) {
  if (preorder.length === 0) return null
  // å‰åºï¼šä¸­å·¦å³
  // ä¸­åºï¼šå·¦ä¸­å³
  const rootval = preorder[0]
  const root = new TreeNode(rootval)
  // æ ¹èŠ‚ç‚¹åœ¨ä¸­åºæ•°ç»„çš„ä¸‹æ ‡
  const in_root_index = inorder.indexOf(rootval)
  // åˆ‡å‰²ä¸­åºæ•°ç»„
  const leftInOrder = inorder.slice(0, in_root_index)
  const rightInOrder = inorder.slice(in_root_index + 1)
  // åˆ‡å‰²å‰åºæ•°ç»„
  const leftPreOrder = preorder.slice(1, leftInOrder.length + 1)
  const rightPreOrder = preorder.slice(leftInOrder.length + 1)

  root.left = buildTree(leftPreOrder, leftInOrder)
  root.right = buildTree(rightPreOrder, rightInOrder)

  return root
}
```

:::

## 20. æœ€å¤§äºŒå‰æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/maximum-binary-tree/description/" />

ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ `nums` ã€‚ `æœ€å¤§äºŒå‰æ ‘` å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» `nums` é€’å½’åœ°æ„å»º:

1. åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º `nums` ä¸­çš„æœ€å¤§å€¼ã€‚
2. é€’å½’åœ°åœ¨æœ€å¤§å€¼ `å·¦è¾¹` çš„ `å­æ•°ç»„å‰ç¼€ä¸Š` æ„å»ºå·¦å­æ ‘ã€‚
3. é€’å½’åœ°åœ¨æœ€å¤§å€¼ `å³è¾¹` çš„ `å­æ•°ç»„åç¼€ä¸Š` æ„å»ºå³å­æ ‘ã€‚

è¿”å› `nums` æ„å»ºçš„ `æœ€å¤§äºŒå‰æ ‘`ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/æœ€å¤§äºŒå‰æ ‘-1.jpg)

> è¾“å…¥ï¼šnums = [3,2,1,6,0,5]
>
> è¾“å‡ºï¼š[6,3,5,null,2,0,null,null,1]
>
> è§£é‡Šï¼šé€’å½’è°ƒç”¨å¦‚ä¸‹æ‰€ç¤ºï¼š
>
> - [3,2,1,6,0,5] ä¸­çš„æœ€å¤§å€¼æ˜¯ 6 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [3,2,1] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [0,5]
>   - [3,2,1] ä¸­çš„æœ€å¤§å€¼æ˜¯ 3 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [2,1]
>     - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹
>     - [2,1] ä¸­çš„æœ€å¤§å€¼æ˜¯ 2 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [1] ã€‚
>       - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹ã€‚
>       - åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥å­èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå€¼ä¸º 1 çš„èŠ‚ç‚¹ã€‚
>   - [0,5] ä¸­çš„æœ€å¤§å€¼æ˜¯ 5 ï¼Œå·¦è¾¹éƒ¨åˆ†æ˜¯ [0] ï¼Œå³è¾¹éƒ¨åˆ†æ˜¯ [] ã€‚
>     - åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥å­èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå€¼ä¸º 0 çš„èŠ‚ç‚¹ã€‚
>     - ç©ºæ•°ç»„ï¼Œæ— å­èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 2**ï¼š

![](./img/æœ€å¤§äºŒå‰æ ‘-2.jpg)

> è¾“å…¥ï¼šnums = [3,2,1]
>
> è¾“å‡ºï¼š[3,null,2,null,1]

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜å’Œä¸Šé¢ä¸¤é“é¢˜å¾ˆåƒï¼Œä½†æ˜¯æ¯”å®ƒä»¬éƒ½ç®€å•ã€‚
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function (nums) {
  if (!nums.length) return null
  // æ‰¾åˆ°æœ€å¤§å€¼
  const max = Math.max(...nums)
  const root = new TreeNode(max)
  // æœ€å¤§å€¼ä¸‹æ ‡
  const max_index = nums.indexOf(max)
  // å·¦æ•°ç»„
  const left = nums.slice(0, max_index)
  // å³æ•°ç»„
  const right = nums.slice(max_index + 1)
  // æ„å»ºå·¦å³å­æ ‘
  root.left = constructMaximumBinaryTree(left)
  root.right = constructMaximumBinaryTree(right)
  return root
}
```

:::

## 21. åˆå¹¶äºŒå‰æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/merge-two-binary-trees/description/" />

ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ï¼š `root1` å’Œ `root2` ã€‚

æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä½ å°†å…¶ä¸­ä¸€æ£µè¦†ç›–åˆ°å¦ä¸€æ£µä¹‹ä¸Šæ—¶ï¼Œä¸¤æ£µæ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹å°†ä¼šé‡å ï¼ˆè€Œå¦ä¸€äº›ä¸ä¼šï¼‰ã€‚ä½ éœ€è¦å°†è¿™ä¸¤æ£µæ ‘åˆå¹¶æˆä¸€æ£µæ–°äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯ï¼šå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ç›¸åŠ ä½œä¸ºåˆå¹¶åèŠ‚ç‚¹çš„æ–°å€¼ï¼›å¦åˆ™ï¼Œä¸ä¸º null çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚

è¿”å›åˆå¹¶åçš„äºŒå‰æ ‘ã€‚

**æ³¨æ„**: åˆå¹¶è¿‡ç¨‹å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/åˆå¹¶äºŒå‰æ ‘.jpg)

> è¾“å…¥ï¼šroot1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
>
> è¾“å‡ºï¼š[3,4,5,5,4,null,7]

**ç¤ºä¾‹ 2**ï¼š

> è¾“å…¥ï¼šroot1 = [1], root2 = [1,2]
>
> è¾“å‡ºï¼š[2,2]

::: code-group

```md [æ€è·¯]
é¢˜ç›®æ„æ€ï¼šæœ‰ä¸¤ä¸ªäºŒå‰æ ‘ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹ä¸¤ä¸ªæ•°éƒ½æœ‰å€¼ï¼Œåˆ™åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ï¼Œå¦åˆ™åªä¿ç•™ä¸ä¸ºç©ºçš„èŠ‚ç‚¹ã€‚
é€’å½’å®ç°ï¼š

1. é€€å‡ºæ¡ä»¶ï¼š

- å½“ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ºç©ºæ—¶ï¼Œè¿”å›ç©º
- å½“ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºæ—¶ï¼Œè¿”å›å¦ä¸€ä¸ªä¸ä¸ºç©ºçš„èŠ‚ç‚¹

2. å•å±‚é€’å½’é€»è¾‘ï¼šæ„å»ºæ–°çš„èŠ‚ç‚¹ï¼ˆæ­¤æ—¶æ„å»ºçš„å°±æ˜¯ä¸¤ä¸ªæ ‘èŠ‚ç‚¹å­˜åœ¨çš„æƒ…å†µï¼‰
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function (root1, root2) {
  // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ºnullï¼Œåˆ™å·²ç»åˆ°åº•
  if (!root1 && !root2) return null
  // å¦‚æœå…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹ä¸ºnullï¼Œè¿”å›å¦ä¸€ä¸ªèŠ‚ç‚¹
  if (!root1) return root2
  if (!root2) return root1

  // ä¸¤ä¸ªèŠ‚ç‚¹éƒ½å­˜åœ¨çš„æƒ…å†µ
  // åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œå€¼ä¸ºä¸¤ä¸ªèŠ‚ç‚¹å€¼çš„å’Œ
  const node = new TreeNode(root1.val + root2.val)
  node.left = mergeTrees(root1.left, root2.left)
  node.right = mergeTrees(root1.right, root2.right)

  return node
}
```

:::

## 22. éªŒè¯äºŒå‰æœç´¢æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/validate-binary-search-tree/description/" />

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚

**æœ‰æ•ˆ** äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š

èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« **ä¸¥æ ¼å°äº** å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« **ä¸¥æ ¼å¤§äº** å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/éªŒè¯äºŒå‰æœç´¢æ ‘-1.jpg)

> è¾“å…¥ï¼šroot = [2,1,3]
>
> è¾“å‡ºï¼štrue

**ç¤ºä¾‹ 2**ï¼š

![](./img/éªŒè¯äºŒå‰æœç´¢æ ‘-2.jpg)

> è¾“å…¥ï¼šroot = [5,1,4,null,null,3,6]
>
> è¾“å‡ºï¼šfalse
>
> è§£é‡Šï¼šæ ¹èŠ‚ç‚¹çš„å€¼æ˜¯ 5 ï¼Œä½†æ˜¯å³å­èŠ‚ç‚¹çš„å€¼æ˜¯ 4 ã€‚

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜å¯ä»¥é‡‡ç”¨ä¸­åºéå†ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯å‡åºï¼ˆåˆç†ä½¿ç”¨æ€§è´¨ï¼‰ã€‚
å› ä¸ºä¸­åºéå†æ˜¯ï¼šå‰ä¸­åï¼Œå¯ä»¥å°†å®ƒä»¬çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¿å­˜ä¸‹æ¥ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦æ˜¯å‡åºã€‚
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
  const arr = []
  function inOrder(node) {
    if (!node) return null
    // ä¸­åºï¼šå‰ä¸­å
    node.left && inOrder(node.left)
    arr.push(node.val)
    node.right && inOrder(node.right)
  }
  inOrder(root)
  // æ’åº
  for (let i = 1; i < arr.length; ++i) {
    if (arr[i] <= arr[i - 1]) return false
  }
  return true
}
```

:::

## 23. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

<LeetCodeLink url="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/" />

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ **å‡åº** æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ **å¹³è¡¡äºŒå‰æœç´¢æ ‘**ã€‚

**ç¤ºä¾‹ 1**ï¼š

![](./img/å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘-1.jpg)

> è¾“å…¥ï¼šnums = [-10,-3,0,5,9]
>
> è¾“å‡ºï¼š[0,-3,9,-10,null,5]
>
> è§£é‡Šï¼š[0,-10,5,null,-3,null,9] ä¹Ÿå°†è¢«è§†ä¸ºæ­£ç¡®ç­”æ¡ˆï¼š
>
> ![](./img/å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘-1.jpg)

**ç¤ºä¾‹ 2**ï¼š

![](./img/å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘-3.jpg)

> è¾“å…¥ï¼šnums = [1,3]
>
> è¾“å‡ºï¼š[3,1]
>
> è§£é‡Šï¼š[1,null,3] å’Œ [3,1] éƒ½æ˜¯é«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚

::: code-group

```md [æ€è·¯]
è¿™é“é¢˜å’Œä¸Šé¢çš„ã€ä¸­åºå’Œååºæ„é€ äºŒå‰æ ‘ã€‘ã€ã€æœ€å¤§äºŒå‰æ ‘ã€‘ä¸€æ ·
æœ¬è´¨å°±æ˜¯å¯»æ‰¾åˆ†å‰²ç‚¹ï¼Œåˆ†å‰²ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹ï¼Œç„¶åé€’å½’å·¦åŒºé—´å’Œå³åŒºé—´ã€‚
ä½†æ˜¯è¿™é“é¢˜æ¯”ä¸Šé¢çš„æ›´ç®€å•ï¼Œå› ä¸ºæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥åˆ†å‰²ç‚¹ç›´æ¥å–ä¸­é—´ç‚¹å³å¯ã€‚

å¦‚æœæ•°ç»„é•¿åº¦ä¸ºå¶æ•°ï¼Œä¸­é—´èŠ‚ç‚¹æœ‰ä¸¤ä¸ªï¼Œå–å“ªä¸€ä¸ªï¼Ÿ
å–å“ªä¸€ä¸ªéƒ½å¯ä»¥ï¼Œåªä¸è¿‡æ„æˆäº†ä¸åŒçš„å¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚
```

```js [ä»£ç ]
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function (nums) {
  return buildTree(nums, 0, nums.length - 1)
}

// arræ•°ç»„ leftä¸‹æ ‡ rightä¸‹æ ‡
function buildTree(arr, left, right) {
  if (left > right) {
    return null
  }
  const mid = Math.floor((left + right) / 2)
  const rootVal = arr[mid]
  const root = new TreeNode(rootVal)
  root.left = buildTree(arr, left, mid - 1)
  root.right = buildTree(arr, mid + 1, right)
  return root
}
```

:::

## 24. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
