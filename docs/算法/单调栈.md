# 单调栈

## 技巧

单调栈是一种单调递增、递减的栈结构，在做题的时候我怎么能想到用单调栈呢？ 什么时候用单调栈呢？

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**，时间复杂度为 O(n)。

那么单调栈的原理是什么呢？为什么时间复杂度是 O(n) 就可以找到每一个元素的右边第一个比它大的元素位置呢？

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

**更直白来说，就是用一个栈来记录我们遍历过的元素**，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？
   - 单调栈里只需要存放元素的下标 i 就可以了，如果需要使用对应的元素，直接 T[i]就可以获取。
2. 单调栈里元素是递增呢？ 还是递减呢？
   > 注意以下讲解中，顺序的描述为**从栈头到栈底的顺序**
   - 例如：在数组中找到当前元素后面最近一个比自己大的元素，那么单调栈里存放的元素是递增的。因为栈顶是最小元素，当我们遇到一个比栈顶大的元素时，说明**栈顶元素找到了它右侧第一个比它大的元素**，此时栈顶元素出栈，继续比较下一个栈顶元素。
   - 即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。

## 1. 每日温度

<LeetCodeLink url="https://leetcode.cn/problems/daily-temperatures/description/" />

给定一个整数数组 `temperatures`，表示每天的温度，返回一个数组 `answer`，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1**:

> **输入**: `temperatures = [73,74,75,71,69,72,76,73]`
>
> **输出**: `[1,1,4,2,1,1,0,0]`

**示例 2**:

> **输入**: `temperatures = [30,40,50,60]`
>
> **输出**: `[1,1,1,0]`

**示例 3**:

> **输入**: `temperatures = [30,60,90]`
>
> **输出**: `[1,1,0]`

::: code-group

```md [思路]
利用单调栈，因为要找当前数后面的元素，除了暴力解法套双循环可以拿到后面的元素，其他情况是拿不到的，
题中又说需要找到当前气温后面第一个比它高的气温，所以就可以维护一个单调栈，栈头到栈顶单调递增，
如果我当前元素下标是 i，**栈不为空**且**栈顶元素小于当前元素**（采用循环），
则说明 i 是栈顶元素后面第一个比它高的气温
```

```js [代码]
/**
 * @param {number[]} temperatures
 * @return {number[]}
 */
var dailyTemperatures = function (temperatures) {
  let len = temperatures.length
  // 存放下标，单调递增栈
  let stack = []
  let ans = Array(len).fill(0)
  for (let i = 0; i < len; i++) {
    // 当前元素
    const cur = temperatures[i]
    while (stack.length !== 0 && cur > temperatures[stack[stack.length - 1]]) {
      // n下标的元素找到了它的右侧最大值（n为之前某个元素的下标）
      let n = stack.pop()
      // 这里是找之间的间隔
      ans[n] = i - n
    }
    stack.push(i)
  }
  return ans
}
```

:::

## 2. 下一个更大元素 I

<LeetCodeLink url="https://leetcode.cn/problems/next-greater-element-i/description/" />

nums1 中数字 `x` 的下一个更大元素 是指 `x` 在 nums2 中对应位置 **右侧** 的第一个比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 0 开始计数，其中 `nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

**示例 1**：

> 输入：`nums1 = [4,1,2]`，`nums2 = [1,3,4,2]`。
>
> 输出：`[-1,3,-1]`
>
> 解释：nums1 中每个值的下一个更大元素如下所述：
>
> - `4` ，用加粗斜体标识，`nums2 = [1,3,4,2]`。不存在下一个更大元素，所以答案是 `-1` 。
>
> - `1` ，用加粗斜体标识，`nums2 = [1,3,4,2]`。下一个更大元素是 `3` 。
>
> - `2` ，用加粗斜体标识，`nums2 = [1,3,4,2]`。不存在下一个更大元素，所以答案是 `-1` 。

**示例 2**：

> 输入：`nums1 = [2,4]`，`nums2 = [1,2,3,4]`。
>
> 输出：`[3,-1]`
>
> 解释：nums1 中每个值的下一个更大元素如下所述：
>
> - `2` ，用加粗斜体标识，`nums2 = [1,2,3,4]`。下一个更大元素是 `3` 。
>
> - `4` ，用加粗斜体标识，`nums2 = [1,2,3,4]`。不存在下一个更大元素，所以答案是 `-1` 。

**提示：**

- nums1 和 nums2 中**所有整数 互不相同**
- nums1 中的所有整数同样出现在 nums2 中

::: code-group

```md [思路]
这里需要处理好两个数组的对应关系，可以采用 hash 表记录 nums1 的值和下标，
需要注意：哈希表记录的是 nums1，循环的是 nums2（当时第一次做的时候两者弄反了），
因为要找 nums2 的下一个更大元素，所以栈中记录的元素也是 nums2 的元素，
剩余的思路和第一题一样，只是在推入栈的时候，需要判断当前元素是不是在 nums1 中
```

```js [代码]
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var nextGreaterElement = function (nums1, nums2) {
  // 记录nums1的值和下标对应关系
  let nums1_map = new Map()
  nums1.forEach((n, i) => nums1_map.set(n, i))
  // ⚠️注意：这里构造的是nums1长度的数组
  let ans = new Array(nums1.length).fill(-1)
  // 存放nums2的下标，单调递增栈
  let stack = []
  for (let i = 0; i < nums2.length; i++) {
    const cur = nums2[i]
    while (stack.length !== 0 && cur > nums2[stack[stack.length - 1]]) {
      // 找到栈顶的元素，当前cur表示为栈顶元素的下一个更大的元素
      const nums2_index_top = stack.pop()
      // nums2已经找到下一个更大元素的该元素（栈顶元素），对应nums1的元素下标
      const nums2_top = nums2[nums2_index_top]
      const nums1_idx = nums1_map.get(nums2_top)
      ans[nums1_idx] = cur
    }
    if (nums1_map.has(cur)) {
      stack.push(i)
    }
  }
  return ans
}
```

:::

## 3. 下一个更大元素 II

<LeetCodeLink url="https://leetcode.cn/problems/next-greater-element-ii/description/" />

给定一个循环数组 `nums`（`nums[nums.length - 1]` 的下一个元素是 `nums[0]`），返回 `nums` 中每个元素的下一个更大元素。

数字 `x` 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1`。

**示例 1**：

> **输入**：`nums = [1,2,1]`
>
> **输出**：`[2,-1,2]`
>
> **解释**：
>
> - 第一个 `1` 的下一个更大的数是 `2`；
>
> - 数字 `2` 找不到下一个更大的数；
>
> - 第二个 `1` 的下一个最大的数需要循环搜索，结果也是 `2`。

**示例 2**：

> **输入**：`nums = [1,2,3,4,3]`
>
> **输出**：`[2,3,4,-1,4]`

::: code-group

```md [思路]
nums 是一个循环数组，nums[n−1] 右边是 nums[0]。我们可以把 nums 复制一份，拼在 nums 右边，这样就把环形数组变成一般数组了。例如 [1,2,1] 变成 [1,2,1,1,2,1]。
依旧与前两题的while循环思路一样，
在push进栈需要判断一下当前元素的下标，i < nums.length（原数组）
```

```js [代码]
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var nextGreaterElements = function (nums) {
  let len = nums.length
  let stack = []
  let ans = new Array(len).fill(-1)
  // 将环形展开成一维数组
  nums = nums.concat(nums)
  for (let i = 0; i < len * 2; i++) {
    const cur = nums[i]
    while (stack.length !== 0 && cur > nums[stack[stack.length - 1]]) {
      const top_i = stack.pop()
      ans[top_i] = cur
    }
    // 因为当前的nums.length是原nums长度的2倍，环形多余的不记
    if (i < len) {
      stack.push(i)
    }
  }
  return ans
}
```

:::
