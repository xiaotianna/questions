{
    "list": [
        {
            "id": 1681,
            "value": 105,
            "time": "2025-09-09T01:57:48.530000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1681,
                "frontend_question_id": "3",
                "question_id": 3,
                "title": "无重复字符的最长子串",
                "content": "<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串 </strong>的长度。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"abcabcbb\"\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>\"abc\"，所以其</code>长度为 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"bbbbb\"\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\"b\"</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"pwwkew\"\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\"wke\"</code>，所以其长度为 3。\n     请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>\"pwke\"</code> 是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"\"\n<strong>输出: </strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由英文字母、数字、符号和空格组成</li>\n</ul>\n",
                "level": 2,
                "slug_title": "longest-substring-without-repeating-characters",
                "expand": false
            },
            "comment_count": 99
        },
        {
            "id": 1519,
            "value": 67,
            "time": "2025-09-11T12:22:01.576000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1519,
                "frontend_question_id": "165",
                "question_id": 165,
                "title": "比较版本号",
                "content": "<p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>\n\n<p>版本号由一个或多个修订号组成，各修订号由一个 <code>'.'</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p>\n\n<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等 </strong>。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 < 1</code> 。</p>\n\n<p>返回规则如下：</p>\n\n<ul>\n\t<li>如果 <code><em>version1 </em>> <em>version2</em></code> 返回 <code>1</code>，</li>\n\t<li>如果 <code><em>version1 </em>< <em>version2</em></code> 返回 <code>-1</code>，</li>\n\t<li>除此之外返回 <code>0</code>。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"1.01\", version2 = \"1.001\"\n<strong>输出：</strong>0\n<strong>解释：</strong>忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"1.0\", version2 = \"1.0.0\"\n<strong>输出：</strong>0\n<strong>解释：</strong>version1 没有指定下标为 2 的修订号，即视为 \"0\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"0.1\", version2 = \"1.1\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>version1 中下标为 0 的修订号是 \"0\"，version2 中下标为 0 的修订号是 \"1\" 。0 < 1，所以 version1 < version2\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"1.0.1\", version2 = \"1\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"7.5.2.4\", version2 = \"7.5.3\"\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= version1.length, version2.length <= 500</code></li>\n\t<li><code>version1</code> 和 <code>version2</code> 仅包含数字和 <code>'.'</code></li>\n\t<li><code>version1</code> 和 <code>version2</code> 都是 <strong>有效版本号</strong></li>\n\t<li><code>version1</code> 和 <code>version2</code> 的所有修订号都可以存储在 <strong>32 位整数</strong> 中</li>\n</ul>\n",
                "level": 2,
                "slug_title": "compare-version-numbers",
                "expand": false
            },
            "comment_count": 28
        },
        {
            "id": 1596,
            "value": 66,
            "time": "2025-09-15T13:57:50.321000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1596,
                "frontend_question_id": "88",
                "question_id": 88,
                "title": "合并两个有序数组",
                "content": "<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组&nbsp;<code>nums1</code><em> </em>和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>\n\n<p>请你 <strong>合并</strong> <code>nums2</code><em> </em>到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>\n\n<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n<strong>输出：</strong>[1,2,2,3,5,6]\n<strong>解释：</strong>需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,<em><strong>3</strong></em>,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1], m = 1, nums2 = [], n = 0\n<strong>输出：</strong>[1]\n<strong>解释：</strong>需要合并 [1] 和 [] 。\n合并结果是 [1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0], m = 0, nums2 = [1], n = 1\n<strong>输出：</strong>[1]\n<strong>解释：</strong>需要合并的数组是 [] 和 [1] 。\n合并结果是 [1] 。\n注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p>\n",
                "level": 1,
                "slug_title": "merge-sorted-array",
                "expand": false
            },
            "comment_count": 41
        },
        {
            "id": 1269,
            "value": 58,
            "time": "2025-09-15T02:38:59.896000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1269,
                "frontend_question_id": "415",
                "question_id": 415,
                "title": "字符串相加",
                "content": "<p>给定两个字符串形式的非负整数&nbsp;<code>num1</code> 和<code>num2</code>&nbsp;，计算它们的和并同样以字符串形式返回。</p>\n\n<p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>），&nbsp;也不能直接将输入的字符串转换为整数形式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"11\", num2 = \"123\"\n<strong>输出：</strong>\"134\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"456\", num2 = \"77\"\n<strong>输出：</strong>\"533\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"0\", num2 = \"0\"\n<strong>输出：</strong>\"0\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>num1</code> 和<code>num2</code> 都只包含数字&nbsp;<code>0-9</code></li>\n\t<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>\n</ul>\n",
                "level": 1,
                "slug_title": "add-strings",
                "expand": false
            },
            "comment_count": 33
        },
        {
            "id": 1664,
            "value": 57,
            "time": "2025-10-12T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1664,
                "frontend_question_id": "20",
                "question_id": 20,
                "title": "有效的括号",
                "content": "<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>\n\n<p>有效字符串需满足：</p>\n\n<ol>\n\t<li>左括号必须用相同类型的右括号闭合。</li>\n\t<li>左括号必须以正确的顺序闭合。</li>\n</ol>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()[]{}\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(]\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"([)]\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"{[]}\"\n<strong>输出：</strong>true</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li>\n</ul>\n",
                "level": 1,
                "slug_title": "valid-parentheses",
                "expand": false
            },
            "comment_count": 28
        },
        {
            "id": 1683,
            "value": 54,
            "time": "2025-04-15T09:13:51.888000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1683,
                "frontend_question_id": "1",
                "question_id": 1,
                "title": "两数之和",
                "content": "<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n\n<p>你可以按任意顺序返回答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,11,15], target = 9\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,4], target = 6\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3], target = 6\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li>\n\t<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n\n<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法吗？</p>\n",
                "level": 1,
                "slug_title": "two-sum",
                "expand": false
            },
            "comment_count": 42
        },
        {
            "id": 1638,
            "value": 48,
            "time": "2025-09-28T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1638,
                "frontend_question_id": "46",
                "question_id": 46,
                "title": "全排列",
                "content": "<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[[0,1],[1,0]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 6</code></li>\n\t<li><code>-10 <= nums[i] <= 10</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
                "level": 2,
                "slug_title": "permutations",
                "expand": false
            },
            "comment_count": 31
        },
        {
            "id": 1478,
            "value": 40,
            "time": "2025-09-14T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1478,
                "frontend_question_id": "206",
                "question_id": 206,
                "title": "反转链表",
                "content": "给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[5,4,3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n\t<li><code>-5000 <= Node.val <= 5000</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n</div>\n</div>\n",
                "level": 1,
                "slug_title": "reverse-linked-list",
                "expand": false
            },
            "comment_count": 46
        },
        {
            "id": 1631,
            "value": 37,
            "time": "2025-09-19T06:57:06.070000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1631,
                "frontend_question_id": "53",
                "question_id": 53,
                "title": "最大子数组和",
                "content": "<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]<strong>输出：</strong>6<strong>解释：</strong>连续子数组 [4,-1,2,1] 的和最大，为 6 。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [1]<strong>输出：</strong>1</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>nums = [0]<strong>输出：</strong>0</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>nums = [-1]<strong>输出：</strong>-1</pre><p><strong>示例 5：</strong></p><pre><strong>输入：</strong>nums = [-100000]<strong>输出：</strong>-100000</pre><p> </p><p><strong>提示：</strong></p><ul>\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\t<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li></ul><p> </p><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>",
                "level": 2,
                "slug_title": "maximum-subarray",
                "expand": false
            },
            "comment_count": 61
        },
        {
            "id": 1582,
            "value": 36,
            "time": "2025-09-02T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1582,
                "frontend_question_id": "102",
                "question_id": 102,
                "title": "二叉树的层序遍历",
                "content": "<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong><br />\n二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回其层序遍历结果：</p>\n\n<pre>\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n</pre>\n",
                "level": 2,
                "slug_title": "binary-tree-level-order-traversal",
                "expand": false
            },
            "comment_count": 39
        },
        {
            "id": 1669,
            "value": 34,
            "time": "2025-04-29T14:58:43.363000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1669,
                "frontend_question_id": "15",
                "question_id": 15,
                "title": "三数之和",
                "content": "<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c = </em>0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>\n\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= nums.length <= 3000</code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "3sum",
                "expand": false
            },
            "comment_count": 64
        },
        {
            "id": 1563,
            "value": 33,
            "time": "2025-09-11T08:07:20.489000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1563,
                "frontend_question_id": "121",
                "question_id": 121,
                "title": "买卖股票的最佳时机",
                "content": "<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>\n\n<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[7,1,5,3,6,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [7,6,4,3,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>在这种情况下, 没有交易完成, 所以最大利润为 0。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= prices.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= prices[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
                "level": 1,
                "slug_title": "best-time-to-buy-and-sell-stock",
                "expand": false
            },
            "comment_count": 26
        },
        {
            "id": 1543,
            "value": 32,
            "time": "2025-10-12T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1543,
                "frontend_question_id": "141",
                "question_id": 141,
                "title": "环形链表",
                "content": "<p>给定一个链表，判断链表中是否有环。</p>\n\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n\n<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\"></p>\n\n<pre><strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\"></p>\n\n<pre><strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>false\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 10<sup>4</sup>]</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>\n</ul>\n",
                "level": 1,
                "slug_title": "linked-list-cycle",
                "expand": false
            },
            "comment_count": 31
        },
        {
            "id": 1572,
            "value": 29,
            "time": "2023-03-16T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1572,
                "frontend_question_id": "112",
                "question_id": 112,
                "title": "路径总和",
                "content": "<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p>\n\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], targetSum = 5\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], targetSum = 0\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>\n\t<li><code>-1000 <= Node.val <= 1000</code></li>\n\t<li><code>-1000 <= targetSum <= 1000</code></li>\n</ul>\n",
                "level": 1,
                "slug_title": "path-sum",
                "expand": false
            },
            "comment_count": 13
        },
        {
            "id": 1614,
            "value": 28,
            "time": "2025-09-17T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1614,
                "frontend_question_id": "70",
                "question_id": 70,
                "title": "爬楼梯",
                "content": "<p>假设你正在爬楼梯。需要 <em>n</em>&nbsp;阶你才能到达楼顶。</p>\n\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n\n<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> 2\n<strong>输出：</strong> 2\n<strong>解释：</strong> 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> 3\n<strong>输出：</strong> 3\n<strong>解释：</strong> 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n</pre>\n",
                "level": 1,
                "slug_title": "climbing-stairs",
                "expand": false
            },
            "comment_count": 21
        },
        {
            "id": 1663,
            "value": 28,
            "time": "2025-07-22T05:51:10.045000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1663,
                "frontend_question_id": "21",
                "question_id": 21,
                "title": "合并两个有序链表",
                "content": "<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" style=\"width: 662px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]\n<strong>输出：</strong>[1,1,2,3,4,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [], l2 = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n\t<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>\n</ul>\n",
                "level": 1,
                "slug_title": "merge-two-sorted-lists",
                "expand": false
            },
            "comment_count": 31
        },
        {
            "id": 1538,
            "value": 27,
            "time": "2025-09-28T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1538,
                "frontend_question_id": "146",
                "question_id": 146,
                "title": "LRU缓存机制",
                "content": "<div class=\"title__3Vvk\">运用你所掌握的数据结构，设计和实现一个  <a href=\"https://baike.baidu.com/item/LRU\" target=\"_blank\">LRU (最近最少使用) 缓存机制</a> 。</div>\n\n<div class=\"original__bRMd\">\n<div>\n<p>实现 <code>LRUCache</code> 类：</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li>\n\t<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>\n\t<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>\n</ul>\n\n<p> </p>\n</div>\n</div>\n\n<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>输出</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>解释</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= capacity <= 3000</code></li>\n\t<li><code>0 <= key <= 10000</code></li>\n\t<li><code>0 <= value <= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "lru-cache",
                "expand": false
            },
            "comment_count": 86
        },
        {
            "id": 1469,
            "value": 27,
            "time": "2025-08-29T04:41:06.589000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1469,
                "frontend_question_id": "215",
                "question_id": 215,
                "title": "数组中的第K个最大元素",
                "content": "<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code><strong>k</strong></code> 个最大的元素。</p>\n\n<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,1,5,6,4] 和</code> k = 2\n<strong>输出:</strong> 5\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,3,1,2,4,5,5,6] 和</code> k = 4\n<strong>输出:</strong> 4</pre>\n\n<p> </p>\n\n<p><strong>提示： </strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "kth-largest-element-in-an-array",
                "expand": false
            },
            "comment_count": 72
        },
        {
            "id": 1906,
            "value": 27,
            "time": "2025-08-27T13:59:31.816000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1906,
                "frontend_question_id": "补充题4",
                "question_id": 99990004,
                "title": "手撕快速排序",
                "content": "<p>给你一个整数数组&nbsp;<code>nums</code>，请你将该数组升序排列。</p><p>&nbsp;</p><ol></ol><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [5,2,3,1]<strong>输出：</strong>[1,2,3,5]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [5,1,1,2,0,0]<strong>输出：</strong>[0,0,1,1,2,5]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ol>\t<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\t<li><code>-50000 &lt;= nums[i] &lt;= 50000</code></li></ol>",
                "level": 2,
                "slug_title": "sort-an-array",
                "expand": false
            },
            "comment_count": 37
        },
        {
            "id": 1679,
            "value": 26,
            "time": "2025-03-07T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1679,
                "frontend_question_id": "5",
                "question_id": 5,
                "title": "最长回文子串",
                "content": "<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babad\"\n<strong>输出：</strong>\"bab\"\n<strong>解释：</strong>\"aba\" 同样是符合题意的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cbbd\"\n<strong>输出：</strong>\"bb\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\"\n<strong>输出：</strong>\"a\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ac\"\n<strong>输出：</strong>\"a\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>\n</ul>\n",
                "level": 2,
                "slug_title": "longest-palindromic-substring",
                "expand": false
            },
            "comment_count": 56
        },
        {
            "id": 1484,
            "value": 24,
            "time": "2025-09-08T11:08:54.448000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1484,
                "frontend_question_id": "200",
                "question_id": 200,
                "title": "岛屿数量",
                "content": "<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>\n\n<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>\n\n<p>此外，你可以假设该网格的四条边均被水包围。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 300</code></li>\n\t<li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "number-of-islands",
                "expand": false
            },
            "comment_count": 34
        },
        {
            "id": 1630,
            "value": 24,
            "time": "2025-04-14T07:08:55.555000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1630,
                "frontend_question_id": "54",
                "question_id": 54,
                "title": "螺旋矩阵",
                "content": "<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 10</code></li>\n\t<li><code>-100 <= matrix[i][j] <= 100</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "spiral-matrix",
                "expand": false
            },
            "comment_count": 51
        },
        {
            "id": 925,
            "value": 20,
            "time": "2025-07-28T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 925,
                "frontend_question_id": "704",
                "question_id": 792,
                "title": "二分查找",
                "content": "<p>给定一个&nbsp;<code>n</code>&nbsp;个元素有序的（升序）整型数组&nbsp;<code>nums</code> 和一个目标值&nbsp;<code>target</code> &nbsp;，写一个函数搜索&nbsp;<code>nums</code>&nbsp;中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>\n\n<p><br>\n<strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 9\n<strong>输出:</strong> 4\n<strong>解释:</strong> 9 出现在 <code>nums</code> 中并且下标为 4\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 2\n<strong>输出:</strong> -1\n<strong>解释:</strong> 2 不存在 <code>nums</code> 中因此返回 -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>你可以假设 <code>nums</code>&nbsp;中的所有元素是不重复的。</li>\n\t<li><code>n</code>&nbsp;将在&nbsp;<code>[1, 10000]</code>之间。</li>\n\t<li><code>nums</code>&nbsp;的每个元素都将在&nbsp;<code>[-9999, 9999]</code>之间。</li>\n</ol>\n",
                "level": 1,
                "slug_title": "binary-search",
                "expand": false
            },
            "comment_count": 25
        },
        {
            "id": 1384,
            "value": 19,
            "time": "2025-04-02T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1384,
                "frontend_question_id": "300",
                "question_id": 300,
                "title": "最长上升子序列",
                "content": "<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n\n<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,3,2,3]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,7,7,7,7,7,7]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 2500</code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>你可以设计时间复杂度为 <code>O(n<sup>2</sup>)</code> 的解决方案吗？</li>\n\t<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>\n</ul>\n",
                "level": 2,
                "slug_title": "longest-increasing-subsequence",
                "expand": false
            },
            "comment_count": 68
        },
        {
            "id": 1555,
            "value": 19,
            "time": "2023-02-04T08:51:36.705000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1555,
                "frontend_question_id": "129",
                "question_id": 129,
                "title": "求根到叶子节点数字之和",
                "content": "给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。\n<div class=\"original__bRMd\">\n<div>\n<p>每条从根节点到叶节点的路径都代表一个数字：</p>\n\n<ul>\n\t<li>例如，从根节点到叶节点的路径 <code>1 -> 2 -> 3</code> 表示数字 <code>123</code> 。</li>\n</ul>\n\n<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>\n\n<p><strong>叶节点</strong> 是指没有子节点的节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>25\n<strong>解释：</strong>\n从根到叶子节点路径 <code>1->2</code> 代表数字 <code>12</code>\n从根到叶子节点路径 <code>1->3</code> 代表数字 <code>13</code>\n因此，数字总和 = 12 + 13 = <code>25</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [4,9,0,5,1]\n<strong>输出：</strong>1026\n<strong>解释：</strong>\n从根到叶子节点路径 <code>4->9->5</code> 代表数字 495\n从根到叶子节点路径 <code>4->9->1</code> 代表数字 491\n从根到叶子节点路径 <code>4->0</code> 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = <code>1026</code>\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 <= Node.val <= 9</code></li>\n\t<li>树的深度不超过 <code>10</code></li>\n</ul>\n</div>\n</div>\n",
                "level": 2,
                "slug_title": "sum-root-to-leaf-numbers",
                "expand": false
            },
            "comment_count": 22
        },
        {
            "id": 1628,
            "value": 18,
            "time": "2025-09-01T08:58:03.244000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1628,
                "frontend_question_id": "56",
                "question_id": 56,
                "title": "合并区间",
                "content": "<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>输出：</strong>[[1,6],[8,10],[15,18]]\n<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[4,5]]\n<strong>输出：</strong>[[1,5]]\n<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= intervals.length <= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10<sup>4</sup></code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "merge-intervals",
                "expand": false
            },
            "comment_count": 46
        },
        {
            "id": 1591,
            "value": 17,
            "time": "2025-09-08T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1591,
                "frontend_question_id": "93",
                "question_id": 93,
                "title": "复原IP地址",
                "content": "<p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 <code>s</code> 获得的 <strong>有效 IP 地址 </strong>。你可以按任何顺序返回答案。</p>\n\n<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>\n\n<p>例如：\"0.1.2.201\" 和 \"192.168.1.1\" 是 <strong>有效</strong> IP 地址，但是 \"0.011.255.245\"、\"192.168.1.312\" 和 \"192.168@1.1\" 是 <strong>无效</strong> IP 地址。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"25525511135\"\n<strong>输出：</strong>[\"255.255.11.135\",\"255.255.111.35\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0000\"\n<strong>输出：</strong>[\"0.0.0.0\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1111\"\n<strong>输出：</strong>[\"1.1.1.1\"]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010010\"\n<strong>输出：</strong>[\"0.10.0.10\",\"0.100.1.0\"]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"101023\"\n<strong>输出：</strong>[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 3000</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
                "level": 2,
                "slug_title": "restore-ip-addresses",
                "expand": false
            },
            "comment_count": 60
        },
        {
            "id": 1362,
            "value": 17,
            "time": "2025-09-05T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1362,
                "frontend_question_id": "322",
                "question_id": 322,
                "title": "零钱兑换",
                "content": "<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>\n\n<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>\n\n<p>你可以认为每种硬币的数量是无限的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[1, 2, 5]</code>, amount = <code>11</code>\n<strong>输出：</strong><code>3</code> \n<strong>解释：</strong>11 = 5 + 5 + 1</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[2]</code>, amount = <code>3</code>\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 0\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 2\n<strong>输出：</strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= coins.length <= 12</code></li>\n\t<li><code>1 <= coins[i] <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 <= amount <= 10<sup>4</sup></code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "coin-change",
                "expand": false
            },
            "comment_count": 25
        },
        {
            "id": 122,
            "value": 15,
            "time": "2025-03-18T09:56:51.560000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 122,
                "frontend_question_id": "剑指 Offer 22",
                "question_id": 100294,
                "title": "链表中倒数第k个节点",
                "content": "<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>\n\n<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n给定一个链表: <strong>1->2->3->4->5</strong>, 和 <em>k </em><strong>= 2</strong>.\n\n返回链表 4<strong>->5</strong>.</pre>\n",
                "level": 1,
                "slug_title": "lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof",
                "expand": false
            },
            "comment_count": 15
        },
        {
            "id": 1580,
            "value": 15,
            "time": "2025-03-05T01:13:43.778000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1580,
                "frontend_question_id": "104",
                "question_id": 104,
                "title": "二叉树的最大深度",
                "content": "<p>给定一个二叉树，找出其最大深度。</p>\n\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n\n<p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p>\n\n<p><strong>示例：</strong><br>\n给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n\n<p>返回它的最大深度&nbsp;3 。</p>\n",
                "level": 1,
                "slug_title": "maximum-depth-of-binary-tree",
                "expand": false
            },
            "comment_count": 22
        },
        {
            "id": 1662,
            "value": 15,
            "time": "2022-10-11T12:34:09.928000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1662,
                "frontend_question_id": "22",
                "question_id": 22,
                "title": "括号生成",
                "content": "<p>数字 <code>n</code>&nbsp;代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>\n\n<p>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[\"()\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "generate-parentheses",
                "expand": false
            },
            "comment_count": 38
        },
        {
            "id": 1590,
            "value": 15,
            "time": "2022-10-07T00:52:26.222000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1590,
                "frontend_question_id": "94",
                "question_id": 94,
                "title": "二叉树的中序遍历",
                "content": "<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 202px; height: 324px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,3]\n<strong>输出：</strong>[1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>\n",
                "level": 1,
                "slug_title": "binary-tree-inorder-traversal",
                "expand": false
            },
            "comment_count": 33
        },
        {
            "id": 142,
            "value": 14,
            "time": "2025-05-31T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 142,
                "frontend_question_id": "剑指 Offer 10- I",
                "question_id": 100274,
                "title": "斐波那契数列",
                "content": "<p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>\n\n<pre>\nF(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.</pre>\n\n<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>\n\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 100</code></li>\n</ul>\n",
                "level": 1,
                "slug_title": "fei-bo-na-qi-shu-lie-lcof",
                "expand": false
            },
            "comment_count": 5
        },
        {
            "id": 1011,
            "value": 14,
            "time": "2025-05-22T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1011,
                "frontend_question_id": "695",
                "question_id": 695,
                "title": "岛屿的最大面积",
                "content": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>\n\n<p><strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>\n\n<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>\n\n<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>输出：</strong>6\n<strong>解释：</strong>答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直这四个方向上的 <code>1</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,0,0,0,0,0,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "max-area-of-island",
                "expand": false
            },
            "comment_count": 18
        },
        {
            "id": 1642,
            "value": 14,
            "time": "2025-04-15T13:10:57.261000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1642,
                "frontend_question_id": "42",
                "question_id": 42,
                "title": "接雨水",
                "content": "<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" style=\"height: 161px; width: 412px;\" /></p>\n\n<pre>\n<strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [4,2,0,3,2,5]\n<strong>输出：</strong>9\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>0 <= n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= height[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
                "level": 3,
                "slug_title": "trapping-rain-water",
                "expand": false
            },
            "comment_count": 48
        },
        {
            "id": 1458,
            "value": 13,
            "time": "2025-09-22T08:02:05.966000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1458,
                "frontend_question_id": "226",
                "question_id": 226,
                "title": "翻转二叉树",
                "content": "<p>翻转一棵二叉树。</p>\n\n<p><strong>示例：</strong></p>\n\n<p>输入：</p>\n\n<pre>     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9</pre>\n\n<p>输出：</p>\n\n<pre>     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1</pre>\n\n<p><strong>备注:</strong><br>\n这个问题是受到 <a href=\"https://twitter.com/mxcl\" target=\"_blank\">Max Howell </a>的 <a href=\"https://twitter.com/mxcl/status/608682016205344768\" target=\"_blank\">原问题</a> 启发的 ：</p>\n\n<blockquote>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</blockquote>\n",
                "level": 1,
                "slug_title": "invert-binary-tree",
                "expand": false
            },
            "comment_count": 17
        },
        {
            "id": 1842,
            "value": 13,
            "time": "2025-08-07T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1842,
                "frontend_question_id": "1556",
                "question_id": 1660,
                "title": "千位分隔数",
                "content": "<p>给你一个整数&nbsp;<code>n</code>，请你每隔三位添加点（即 &quot;.&quot; 符号）作为千位分隔符，并将结果以字符串格式返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 987\n<strong>输出：</strong>&quot;987&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 1234\n<strong>输出：</strong>&quot;1.234&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 123456789\n<strong>输出：</strong>&quot;123.456.789&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 0\n<strong>输出：</strong>&quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt; 2^31</code></li>\n</ul>\n",
                "level": 1,
                "slug_title": "thousand-separator",
                "expand": false
            },
            "comment_count": 8
        },
        {
            "id": 1622,
            "value": 13,
            "time": "2025-02-25T14:47:46.047000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1622,
                "frontend_question_id": "62",
                "question_id": 62,
                "title": "不同路径",
                "content": "<p>一个机器人位于一个 <code>m x n</code><em> </em>网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n\n<p>问总共有多少条不同的路径？</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" />\n<pre>\n<strong>输入：</strong>m = 3, n = 7\n<strong>输出：</strong>28</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 7, n = 3\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 3\n<strong>输出：</strong>6</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li>题目数据保证答案小于等于 <code>2 * 10<sup>9</sup></code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "unique-paths",
                "expand": false
            },
            "comment_count": 21
        },
        {
            "id": 485,
            "value": 12,
            "time": "2025-10-11T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 485,
                "frontend_question_id": "1143",
                "question_id": 1250,
                "title": "最长公共子序列",
                "content": "<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>\n\n<p>一个字符串的 <strong>子序列</strong><em> </em>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"abcde\"</code> 的子序列，但 <code>\"aec\"</code> 不是 <code>\"abcde\"</code> 的子序列。</li>\n</ul>\n\n<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abcde\", text2 = \"ace\" \n<strong>输出：</strong>3  \n<strong>解释：</strong>最长公共子序列是 \"ace\" ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abc\", text2 = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最长公共子序列是 \"abc\" ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abc\", text2 = \"def\"\n<strong>输出：</strong>0\n<strong>解释：</strong>两个字符串没有公共子序列，返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= text1.length, text2.length <= 1000</code></li>\n\t<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>\n</ul>\n",
                "level": 2,
                "slug_title": "longest-common-subsequence",
                "expand": false
            },
            "comment_count": 35
        },
        {
            "id": 1401,
            "value": 12,
            "time": "2025-09-22T08:02:05.966000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1401,
                "frontend_question_id": "283",
                "question_id": 283,
                "title": "移动零",
                "content": "<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> <code>[0,1,0,3,12]</code>\n<strong>输出:</strong> <code>[1,3,12,0,0]</code></pre>\n\n<p><strong>说明</strong>:</p>\n\n<ol>\n\t<li>必须在原数组上操作，不能拷贝额外的数组。</li>\n\t<li>尽量减少操作次数。</li>\n</ol>\n",
                "level": 1,
                "slug_title": "move-zeroes",
                "expand": false
            },
            "comment_count": 17
        },
        {
            "id": 1670,
            "value": 12,
            "time": "2025-04-23T07:24:50.621000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1670,
                "frontend_question_id": "14",
                "question_id": 14,
                "title": "最长公共前缀",
                "content": "<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n\n<p>如果不存在公共前缀，返回空字符串&nbsp;<code>\"\"</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"flower\",\"flow\",\"flight\"]\n<strong>输出：</strong>\"fl\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"dog\",\"racecar\",\"car\"]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>输入不存在公共前缀。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
                "level": 1,
                "slug_title": "longest-common-prefix",
                "expand": false
            },
            "comment_count": 19
        },
        {
            "id": 1448,
            "value": 12,
            "time": "2024-12-05T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1448,
                "frontend_question_id": "236",
                "question_id": 236,
                "title": "二叉树的最近公共祖先",
                "content": "<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出：</strong>5\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5 。</code>因为根据定义最近公共祖先节点可以为节点本身。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], p = 1, q = 2\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[2, 10<sup>5</sup>]</code> 内。</li>\n\t<li><code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code></li>\n\t<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>\n</ul>\n",
                "level": 2,
                "slug_title": "lowest-common-ancestor-of-a-binary-tree",
                "expand": false
            },
            "comment_count": 31
        },
        {
            "id": 1581,
            "value": 12,
            "time": "2024-03-05T16:56:27.239000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1581,
                "frontend_question_id": "103",
                "question_id": 103,
                "title": "二叉树的锯齿形层次遍历",
                "content": "<p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>\n\n<p>例如：<br />\n给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回锯齿形层序遍历如下：</p>\n\n<pre>\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n</pre>\n",
                "level": 2,
                "slug_title": "binary-tree-zigzag-level-order-traversal",
                "expand": false
            },
            "comment_count": 42
        },
        {
            "id": 1659,
            "value": 11,
            "time": "2025-04-15T04:16:13.428000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1659,
                "frontend_question_id": "25",
                "question_id": 25,
                "title": "K 个一组翻转链表",
                "content": "<p>给你一个链表，每 <em>k </em>个节点一组进行翻转，请你返回翻转后的链表。</p>\n\n<p><em>k </em>是一个正整数，它的值小于或等于链表的长度。</p>\n\n<p>如果节点总数不是 <em>k </em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>\n\t<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[2,1,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 3\n<strong>输出：</strong>[3,2,1,4,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 1\n<strong>输出：</strong>[1,2,3,4,5]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], k = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<ul>\n</ul>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>列表中节点的数量在范围 <code>sz</code> 内</li>\n\t<li><code>1 <= sz <= 5000</code></li>\n\t<li><code>0 <= Node.val <= 1000</code></li>\n\t<li><code>1 <= k <= sz</code></li>\n</ul>\n",
                "level": 3,
                "slug_title": "reverse-nodes-in-k-group",
                "expand": false
            },
            "comment_count": 77
        },
        {
            "id": 1682,
            "value": 11,
            "time": "2024-08-26T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1682,
                "frontend_question_id": "2",
                "question_id": 2,
                "title": "两数相加",
                "content": "<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>\n\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg\" style=\"width: 483px; height: 342px;\" />\n<pre>\n<strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[7,0,8]\n<strong>解释：</strong>342 + 465 = 807.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [0], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>输出：</strong>[8,9,9,9,0,0,0,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>0 <= Node.val <= 9</code></li>\n\t<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n",
                "level": 2,
                "slug_title": "add-two-numbers",
                "expand": false
            },
            "comment_count": 26
        },
        {
            "id": 1475,
            "value": 11,
            "time": "2024-03-17T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1475,
                "frontend_question_id": "209",
                "question_id": 209,
                "title": "长度最小的子数组",
                "content": "<p>给定一个含有 <code>n</code><strong> </strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p>\n\n<p>找出该数组中满足其和<strong> </strong><code>≥ target</code><strong> </strong>的长度最小的 <strong>连续子数组</strong> <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>子数组 <code>[4,3]</code> 是该条件下的长度最小的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 4, nums = [1,4,4]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= target <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>\n</ul>\n",
                "level": 2,
                "slug_title": "minimum-size-subarray-sum",
                "expand": false
            },
            "comment_count": 35
        },
        {
            "id": 1641,
            "value": 10,
            "time": "2025-09-08T08:49:31.953000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1641,
                "frontend_question_id": "43",
                "question_id": 43,
                "title": "字符串相乘",
                "content": "<p>给定两个以字符串形式表示的非负整数&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>，返回&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的乘积，它们的乘积也表示为字符串形式。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> num1 = &quot;2&quot;, num2 = &quot;3&quot;\n<strong>输出:</strong> &quot;6&quot;</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> num1 = &quot;123&quot;, num2 = &quot;456&quot;\n<strong>输出:</strong> &quot;56088&quot;</pre>\n\n<p><strong>说明：</strong></p>\n\n<ol>\n\t<li><code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的长度小于110。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code> 只包含数字&nbsp;<code>0-9</code>。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;均不以零开头，除非是数字 0 本身。</li>\n\t<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>\n</ol>\n",
                "level": 2,
                "slug_title": "multiply-strings",
                "expand": false
            },
            "comment_count": 31
        },
        {
            "id": 1485,
            "value": 10,
            "time": "2025-06-04T13:10:47.219000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1485,
                "frontend_question_id": "199",
                "question_id": 199,
                "title": "二叉树的右视图",
                "content": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 270px; \" /></p>\n\n<pre>\n<strong>输入:</strong> [1,2,3,null,5,null,4]\n<strong>输出:</strong> [1,3,4]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,null,3]\n<strong>输出:</strong> [1,3]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> []\n<strong>输出:</strong> []\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-100 <= Node.val <= 100</code> </li>\n</ul>\n",
                "level": 2,
                "slug_title": "binary-tree-right-side-view",
                "expand": false
            },
            "comment_count": 38
        },
        {
            "id": 1486,
            "value": 10,
            "time": "2025-05-29T01:52:51.208000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1486,
                "frontend_question_id": "198",
                "question_id": 198,
                "title": "打家劫舍",
                "content": "<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,7,9,3,1]\n<strong>输出：</strong>12\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 100</code></li>\n\t<li><code>0 <= nums[i] <= 400</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "house-robber",
                "expand": false
            },
            "comment_count": 16
        },
        {
            "id": 1524,
            "value": 10,
            "time": "2025-05-05T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1524,
                "frontend_question_id": "160",
                "question_id": 160,
                "title": "相交链表",
                "content": "<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Intersected at '8'\n<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" style=\"height: 136px; width: 350px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Intersected at '2'\n<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>listA</code> 中节点数目为 <code>m</code></li>\n\t<li><code>listB</code> 中节点数目为 <code>n</code></li>\n\t<li><code>0 <= m, n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= Node.val <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= skipA <= m</code></li>\n\t<li><code>0 <= skipB <= n</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n",
                "level": 1,
                "slug_title": "intersection-of-two-linked-lists",
                "expand": false
            },
            "comment_count": 34
        },
        {
            "id": 999,
            "value": 10,
            "time": "2022-04-24T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 999,
                "frontend_question_id": "718",
                "question_id": 718,
                "title": "最长重复子数组",
                "content": "<p>给两个整数数组&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;，返回两个数组中公共的、长度最长的子数组的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n长度最长的公共子数组是 [3, 2, 1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= len(A), len(B) &lt;= 1000</code></li>\n\t<li><code>0 &lt;= A[i], B[i] &lt; 100</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "maximum-length-of-repeated-subarray",
                "expand": false
            },
            "comment_count": 31
        },
        {
            "id": 1290,
            "value": 9,
            "time": "2025-07-22T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1290,
                "frontend_question_id": "394",
                "question_id": 394,
                "title": "字符串解码",
                "content": "<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>\n\n<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p>\n\n<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>\n\n<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像&nbsp;<code>3a</code>&nbsp;或&nbsp;<code>2[4]</code>&nbsp;的输入。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3[a]2[bc]&quot;\n<strong>输出：</strong>&quot;aaabcbc&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3[a2[c]]&quot;\n<strong>输出：</strong>&quot;accaccacc&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;2[abc]3[cd]ef&quot;\n<strong>输出：</strong>&quot;abcabccdcdcdef&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc3[cd]xyz&quot;\n<strong>输出：</strong>&quot;abccdcdcdxyz&quot;\n</pre>\n",
                "level": 2,
                "slug_title": "decode-string",
                "expand": false
            },
            "comment_count": 31
        },
        {
            "id": 1579,
            "value": 9,
            "time": "2025-05-31T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1579,
                "frontend_question_id": "105",
                "question_id": 105,
                "title": "从前序与中序遍历序列构造二叉树",
                "content": "<p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历  <code>inorder</code>。请构造二叉树并返回其根节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" />\n<pre>\n<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 <= preorder.length <= 3000</code></li>\n\t<li><code>inorder.length == preorder.length</code></li>\n\t<li><code>-3000 <= preorder[i], inorder[i] <= 3000</code></li>\n\t<li><code>preorder</code> 和 <code>inorder</code> 均无重复元素</li>\n\t<li><code>inorder</code> 均出现在 <code>preorder</code></li>\n\t<li><code>preorder</code> 保证为二叉树的前序遍历序列</li>\n\t<li><code>inorder</code> 保证为二叉树的中序遍历序列</li>\n</ul>\n",
                "level": 2,
                "slug_title": "construct-binary-tree-from-preorder-and-inorder-traversal",
                "expand": false
            },
            "comment_count": 19
        },
        {
            "id": 1583,
            "value": 9,
            "time": "2025-04-24T07:16:20.848000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1583,
                "frontend_question_id": "101",
                "question_id": 101,
                "title": "对称二叉树",
                "content": "<p>给定一个二叉树，检查它是否是镜像对称的。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，二叉树&nbsp;<code>[1,2,2,3,4,4,3]</code> 是对称的。</p>\n\n<pre>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</pre>\n\n<p>&nbsp;</p>\n\n<p>但是下面这个&nbsp;<code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n\n<pre>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>\n",
                "level": 1,
                "slug_title": "symmetric-tree",
                "expand": false
            },
            "comment_count": 17
        },
        {
            "id": 1665,
            "value": 9,
            "time": "2025-04-02T16:00:00Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1665,
                "frontend_question_id": "19",
                "question_id": 19,
                "title": "删除链表的倒数第N个节点",
                "content": "<p>给你一个链表，删除链表的倒数第 <code>n</code><em> </em>个结点，并且返回链表的头结点。</p>\n\n<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], n = 2\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], n = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中结点的数目为 <code>sz</code></li>\n\t<li><code>1 <= sz <= 30</code></li>\n\t<li><code>0 <= Node.val <= 100</code></li>\n\t<li><code>1 <= n <= sz</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "remove-nth-node-from-end-of-list",
                "expand": false
            },
            "comment_count": 31
        },
        {
            "id": 1529,
            "value": 9,
            "time": "2025-02-26T04:15:29.401000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1529,
                "frontend_question_id": "155",
                "question_id": 155,
                "title": "最小栈",
                "content": "<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n\n<ul>\n\t<li><code>push(x)</code> &mdash;&mdash; 将元素 x 推入栈中。</li>\n\t<li><code>pop()</code>&nbsp;&mdash;&mdash; 删除栈顶的元素。</li>\n\t<li><code>top()</code>&nbsp;&mdash;&mdash; 获取栈顶元素。</li>\n\t<li><code>getMin()</code> &mdash;&mdash; 检索栈中的最小元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>输出：</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>解释：</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>\n</ul>\n",
                "level": 1,
                "slug_title": "min-stack",
                "expand": false
            },
            "comment_count": 29
        },
        {
            "id": 1300,
            "value": 9,
            "time": "2022-07-06T10:21:05.962000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1300,
                "frontend_question_id": "384",
                "question_id": 384,
                "title": "打乱数组",
                "content": "<p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。</p>\n\n<p>实现 <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li>\n\t<li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li>\n\t<li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\n[[[1, 2, 3]], [], [], []]\n<strong>输出</strong>\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\n<strong>解释</strong>\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]\nsolution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]\nsolution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 200</code></li>\n\t<li><code>-10<sup>6</sup> <= nums[i] <= 10<sup>6</sup></code></li>\n\t<li><code>nums</code> 中的所有元素都是 <strong>唯一的</strong></li>\n\t<li>最多可以调用 <code>5 * 10<sup>4</sup></code> 次 <code>reset</code> 和 <code>shuffle</code></li>\n</ul>\n",
                "level": 2,
                "slug_title": "shuffle-an-array",
                "expand": false
            },
            "comment_count": 16
        },
        {
            "id": 1540,
            "value": 9,
            "time": "2021-11-30T07:20:50.349000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1540,
                "frontend_question_id": "144",
                "question_id": 144,
                "title": "二叉树的前序遍历",
                "content": "<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong><em> </em>遍历。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 202px; height: 324px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,3]\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>\n",
                "level": 1,
                "slug_title": "binary-tree-preorder-traversal",
                "expand": false
            },
            "comment_count": 11
        },
        {
            "id": 1559,
            "value": 8,
            "time": "2025-09-16T08:13:00.711000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 1559,
                "frontend_question_id": "125",
                "question_id": 125,
                "title": "验证回文串",
                "content": "<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>\n\n<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \"A man, a plan, a canal: Panama\"\n<strong>输出:</strong> true\n<strong>解释：</strong>\"amanaplanacanalpanama\" 是回文串\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \"race a car\"\n<strong>输出:</strong> false\n<strong>解释：</strong>\"raceacar\" 不是回文串\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 2 * 10<sup>5</sup></code></li>\n\t<li>字符串 <code>s</code> 由 ASCII 字符组成</li>\n</ul>\n",
                "level": 1,
                "slug_title": "valid-palindrome",
                "expand": false
            },
            "comment_count": 10
        },
        {
            "id": 239,
            "value": 8,
            "time": "2023-08-24T05:59:18.087000Z",
            "status": false,
            "note_status": false,
            "rate": 0,
            "leetcode": {
                "id": 239,
                "frontend_question_id": "1444",
                "question_id": 1555,
                "title": "切披萨的方案数",
                "content": "<p>给你一个&nbsp;<code>rows x cols</code>&nbsp;大小的矩形披萨和一个整数 <code>k</code>&nbsp;，矩形包含两种字符：&nbsp;<code>&#39;A&#39;</code> （表示苹果）和&nbsp;<code>&#39;.&#39;</code>&nbsp;（表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到&nbsp;<code>k</code>&nbsp;块披萨并送给别人。</p>\n\n<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>\n\n<p>请你返回确保每一块披萨包含&nbsp;<strong>至少</strong>&nbsp;一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/ways_to_cut_apple_1.png\" style=\"height: 378px; width: 500px;\"></strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3\n<strong>输出：</strong>3 \n<strong>解释：</strong>上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 50</code></li>\n\t<li><code>rows ==&nbsp;pizza.length</code></li>\n\t<li><code>cols ==&nbsp;pizza[i].length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>pizza</code>&nbsp;只包含字符&nbsp;<code>&#39;A&#39;</code>&nbsp;和&nbsp;<code>&#39;.&#39;</code>&nbsp;。</li>\n</ul>\n",
                "level": 3,
                "slug_title": "number-of-ways-of-cutting-a-pizza",
                "expand": false
            },
            "comment_count": 4
        }
    ]
}