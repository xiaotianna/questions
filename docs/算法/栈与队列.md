# 栈与队列

## 栈与队列理论基础

### 栈（Stack）——只用 pop 和 push 完成增删的“数组”

特点：`后进先出`，类似于 `拿盘子`

```js
// 初始状态，栈空
const stack = []
// 入栈过程
stack.push('东北大板')
stack.push('可爱多')
stack.push('巧乐兹')
stack.push('冰工厂')
stack.push('光明奶砖')

// 出栈过程，栈不为空时才执行
while (stack.length) {
  // 单纯访问栈顶元素（不出栈）
  const top = stack[stack.length - 1]
  console.log('现在取出的冰淇淋是', top)
  // 将栈顶元素出栈
  stack.pop()
}

// 栈空
stack // []
```

```bash
现在取出的冰淇淋是 光明奶砖
现在取出的冰淇淋是 冰工厂
现在取出的冰淇淋是 巧乐兹
现在取出的冰淇淋是 可爱多
现在取出的冰淇淋是 东北大板
```

### 队列（Queue）——只用 shift 和 push 完成增删的“数组”

特点：`先进先出`，类似于 `排队`

```js
const queue = []
queue.push('user1')
queue.push('user2')
queue.push('user3')

while (queue.length) {
  // 单纯访问队头元素（不出队）
  const top = queue[0]
  console.log(top, '取餐')
  // 将队头元素出队
  queue.shift()
}

// 队空
queue // []
```

```bash
user1 取餐
user2 取餐
user3 取餐
```

## 1. 用栈实现队列

<LeetCodeLink url="https://leetcode.cn/problems/implement-queue-using-stacks/description/" />

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 `x` 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true`；否则，返回 `false`

**说明**：

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`，`peek/pop from top`，`size`，和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 `list` 或者 `deque`（双端队列）来模拟一个栈，只要是标准的栈操作即可。

**示例 1**：

> **输入**：
>
> ["MyQueue", "push", "push", "peek", "pop", "empty"]
>
> [[], [1], [2], [], [], []]
>
> **输出**：
>
> [null, null, null, 1, 1, false]
>
> **解释**：
>
> MyQueue myQueue = new MyQueue();
>
> myQueue.push(1); // queue is: [1]
>
> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
>
> myQueue.peek(); // return 1
>
> myQueue.pop(); // return 1, queue is [2]
>
> myQueue.empty(); // return false

::: code-group

```md [思路]
题中说使用**两个栈**实现队列，栈的话就只能使用数组的 `pop` 和 `push` 方法。

队列是先进先出，定义一个 `stackIn` 栈，用来将元素压入栈中，实现队列的进；
定义一个 `stackOut` 栈，用来将元素弹出栈，实现队列的出。

- myQueue.push()：直接在 `stackIn` 栈中压入元素
- myQueue.pop()：如果 `stackOut` 栈不为空，直接弹出栈顶元素即可；如果为空，则将 `stackIn` 栈中的元素全部压入 `stackOut` 栈中（相当于将 `stackIn` 栈中的元素倒序压入 `stackOut` 栈中），再弹出栈顶元素

例如：
stackIn: 【1,2,3<-入口
依次将 3、2、1 弹出 stackIn，放入 stackOut 中
stackOut: 出口<-3,2,1】

- myQueue.peek()：返回队列第一个元素，可以调用 `myQueue.pop()` 方法，该方法会返回并删除队列第一个元素。所以需要重新将该元素 `push` 放回 `stackOut` 中。
- myQueue.empty()：两个栈都为空时，才返回 true
```

```js [代码]
var MyQueue = function () {
  this.stackIn = []
  this.stackOut = []
}

/**
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function (x) {
  this.stackIn.push(x)
}

/**
 * @return {number}
 */
MyQueue.prototype.pop = function () {
  let size = this.stackOut.length
  if (size) {
    return this.stackOut.pop()
  }
  while (this.stackIn.length) {
    const last = this.stackIn.pop()
    this.stackOut.push(last)
  }
  return this.stackOut.pop()
}

/**
 * @return {number}
 */
MyQueue.prototype.peek = function () {
  // 获取队头元素，并且从stackOut栈中删去了
  const res = this.pop()
  // 需要重新放回stackOut中
  this.stackOut.push(res)
  return res
}

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function () {
  return !this.stackIn.length && !this.stackOut.length
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

:::

## 2. 用队列实现栈

<LeetCodeLink url="https://leetcode.cn/problems/implement-stack-using-queues/description/" />

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 `x` 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true`；否则，返回 `false` 。

**注意**：

- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。你可以使用 `list`（列表）或者 `deque`（双端队列）来模拟一个队列，只要是标准的队列操作即可。

**示例**：

> **输入**：
>
> ["MyStack", "push", "push", "top", "pop", "empty"]
>
> [[], [1], [2], [], [], []]
>
> **输出**：
>
> [null, null, null, 2, 2, false]
>
> **解释**：
>
> MyStack myStack = new MyStack();
>
> myStack.push(1);
>
> myStack.push(2);
>
> myStack.top(); // 返回 2
>
> myStack.pop(); // 返回 2
>
> myStack.empty(); // 返回 False

::: code-group

```md [思路]
题中说需要两个队列，队列只能使用数组的 shift 和 push 方法

- myStack.push()：直接 push 到 inQueue
- myStack.pop()：由于需要弹出最后进来的元素，但是又不能使用 pop，shift 只能弹出第一个元素

1. 判断 inQueue 的长度是否大于 1（采用循环），大于 1 就表示队列里还有其他的元素，
   就可以采用一个新的队列 saveQueue 来暂存之前的元素（除去最后的，之前的元素都保存在 saveQueue 中）
   然后去操作 inQueue 的 shift 拿到的末尾元素
2. 判断 inQueue 是否有元素，为空，可能 saveQueue 中有，就把 saveQueue 的复制到 inQueue 中，saveQueue 置空即可

- myStack.top()：可以调用 `myStack.pop()` 方法，最后将 `myStack.pop()` 弹出的元素，再添加回去即可
- myStack.empty()：两个队列长度为空，则返回 true
```

```js [代码]
var MyStack = function () {
  // 入栈 <- [1,2,3] <- 3进
  // 出栈 3出 -> [3,2,1] ->
  this.inQueue = []
  // 暂存的
  this.saveQueue = []
}

/**
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function (x) {
  // push是放入栈的末尾
  this.inQueue.push(x)
}

/**
 * @return {number}
 */
MyStack.prototype.pop = function () {
  if (!this.inQueue.length) {
    // 如果为空，暂存的saveQueue可能有元素，需要将暂存的原封不动的放回inQueue
    // [this.inQueue, this.saveQueue] = [this.saveQueue, this.inQueue];
    this.inQueue = this.saveQueue
    this.saveQueue = []
  }
  // 把inQueue除第一个元素的其他元素放入saveQueue进行暂存，确保只剩最后进入的
  while (this.inQueue.length > 1) {
    // 先进的元素
    const firstN = this.inQueue.shift()
    this.saveQueue.push(firstN)
  }
  return this.inQueue.shift()
}

/**
 * @return {number}
 */
MyStack.prototype.top = function () {
  const res = this.pop()
  // inQueue <- [1,2,3] <- 栈顶是3
  this.inQueue.push(res)
  return res
}

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function () {
  return !this.inQueue.length && !this.saveQueue.length
}

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```

:::

## 3. 有效的括号

<LeetCodeLink url="https://leetcode.cn/problems/valid-parentheses/description/" />

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s`，判断字符串是否有效。

有效字符串需满足：
1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1**:

输入: `s = "()"`  
输出: `true`  

**示例 2**:

输入: `s = "()[]{}"`  
输出: `true`  

**示例 3**:

输入: `s = "(]"`  
输出: `false`  

**示例 4**:

输入: `s = "([)]"`  
输出: `false`  

**示例 5**:

输入: `s = "{[]}"`  
输出: `true`