# 双指针

这部分在之前的算法中有涉及到，下面是涉及到的题目：

- [移除元素](/算法/数组.html#_2-移除元素)
- [反转字符串](/算法/字符串.html#_1-反转字符串-【简单】)
- [反转字符串中的单词](/算法/字符串.html#_5-反转字符串中的单词)
- [反转链表](/算法/链表.html#_3-反转链表)
- [删除链表的倒数第 n 个结点](/算法/链表.html#_5-删除链表的倒数第-n-个结点)
- [相交链表](/算法/链表.html#_6-相交链表)
- [环形链表 II](/算法/链表.html#_8-环形链表-ii-7-的-plus-版)

## 1.合并排序

给定两个已排序（升序）好的数组，将两个数组合并为一个新的数组，并使新数组仍然有序

```js
function mergeSort(arr1, arr2) {}

console.log(mergeSort([1, 3, 5], [2, 4, 6, 8])) // [1, 2, 3, 4, 5, 6, 8]
```

**解析**：双指针

```md
⬇️
1, 3, 5
2, 4, 6
⬆️
result = []
比较两个指针的值，小的放入 result 中，指针后移
```

```js
function mergeSort(arr1, arr2) {
  // arr1的指针
  let p1 = 0
  // arr2的指针
  let p2 = 0
  // 存放最后排序结果的数组
  const result = []

  while (p1 < arr1.length || p2 < arr2.length) {
    if (arr1[p1] < arr2[p2]) {
      // arr1[i] 比 arr2[j] 小
      result.push(arr1[p1])
      p1++
    } else if (arr1[p1] > arr2[p2]) {
      // arr1[i] 比 arr2[j] 大
      result.push(arr2[p2])
      p2++
    } else if (p1 >= arr1.length) {
      // arr1已经走完，将arr2剩余内容放入result中
      result.push(arr2[p2])
      p2++
    } else if (p2 >= arr2.length) {
      // arr2已经走完，将arr1剩余内容放入result中
      result.push(arr1[p1])
      p1++
    }
  }

  return result
}

console.log(mergeSort([1, 3, 5], [2, 4, 6, 8])) // [1, 2, 3, 4, 5, 6, 8]
```

## 2. 盛最多水的容器

<LeetCodeLink url="https://leetcode.cn/problems/container-with-most-water/description/" />

给定一个长度为 n 的整数数组 `height` 。有 n 条垂线，第 i 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

**示例 1：**

![](./img/盛最多水的容器.jpg)

> 输入：[1,8,6,2,5,4,8,3,7]
>
> 输出：49
>
> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

**示例 2**：

> 输入：height = [1,1]
>
> 输出：1

::: code-group

```md [思路]
采用双指针来解，需要找到区域面积最大，不断将左右指针内向移动，依次判断大小即可，
如果左指针的值小于右指针的值，则将左指针向右移动，反之亦然。
```

```js [代码]
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
  let left = 0
  let right = height.length - 1
  let maxArea = 0 // 最大面积
  while (left < right) {
    // (right - left)：长  Math.min(height[left], height[right])：高
    const currentArea = (right - left) * Math.min(height[left], height[right])
    maxArea = Math.max(maxArea, currentArea)
    // 左侧短，向内移动
    if (height[left] < height[right]) {
      left++
    } else {
      right--
    }
  }
  return maxArea
}
```

:::

## 3. 判断回文串

回文串是向前和向后读都相同的字符串。判断一个字符串是不是回文串。

::: code-group

```md [思路]
可以使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。
```

```js [代码]
// 判断是否是回文串
function isPalindrome(str) {
  let left = 0
  let right = str.length - 1
  while (left < right) {
    if (str[left] !== str[right]) {
      return false
    }
    left++
    right--
  }
  return true
}
```

:::
