# 二叉树基础知识

## 树结构

- 树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
- 结点和树的“高度”计算规则：叶子结点高度记为 1，每向上一层高度就加 1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
- “度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。
- “叶子结点”：叶子结点就是度为 0 的结点。

## 二叉树结构

二叉树是指满足以下要求的树：

- 它可以没有根结点，作为一棵空树存在
  > 空树的含义：空树是指不包含任何节点的树，即连根节点都不存在。这是树这种数据结构的一个合法状态，就像空数组、空链表一样，是数据结构的边界情况。空树通常用 null 或 None 来表示树的根节点指针
- 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。如下图：

![](./img/二叉树结构.png)

注意：**二叉树不能被简单定义为每个结点的度都是 2 的树**。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。

## 二叉树的种类

### 1. 满二叉树

满二叉树：如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树。

![](./img/满二叉树.png)

这棵二叉树为满二叉树，也可以说深度为 k，有 2^k-1 个节点的二叉树。

### 2. 完全二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且**最下面一层的节点都集中在该层最左边的若干位置**。若最底层为第 h 层（h 从 1 开始），则该层包含 1~ 2^(h-1) 个节点。

![](./img/完全二叉树.png)

最后一个不是是因为图中方框的内容没有节点，需要从左依次排满

### 3. 二叉搜索树

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

![](./img/二叉搜索树.png)

### 4. 平衡二叉搜索树（平衡二叉树）

平衡二叉搜索树：又被称为 AVL 树，且具有以下性质：它是一棵空树或它的**左右两个子树的高度差的绝对值不超过 1**，并且左右两个子树都是一棵平衡二叉搜索树。

![](./img/平衡二叉搜索树.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了 1。

## 二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储**。

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

| 链式存储                       | 顺序存储                                                                                                      |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| ![](./img/二叉树存储-链式.png) | ![](./img/二叉树存储-顺序.png) 如果父节点的数组下标是 i，那么它的左孩子就是 i _ 2 + 1，右孩子就是 i _ 2 + 2。 |

因为勇链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

## 二叉树的定义（编码实现）

在 JS 中，二叉树使用对象来定义。它的结构分为三块：

- 数据域
- 左侧子结点（左子树根结点）的引用
- 右侧子结点（右子树根结点）的引用

在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：

```js
function TreeNode(val, left, right) {
  this.val = val === undefined ? 0 : val
  this.left = left === undefined ? null : left
  this.right = right === undefined ? null : right
}
```

当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：

```js
const node = new TreeNode(1)
```

以这个结点为根结点，我们可以通过给 left/right 赋值拓展其子树信息，延展出一棵二叉树。因此从更加细化的角度来看，一棵二叉树的形态实际是这样的：

![](./img/二叉树编码实现.png)

## 二叉树的遍历方式

二叉树主要有两种遍历方式：

- [**深度优先遍历**](/算法/深度优先和广度优先)：先往深走，遇到叶子节点再往回走。
- [**广度优先遍历**](/算法/深度优先和广度优先)：一层一层的去遍历。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

在深度优先遍历中：有三个顺序，前中后序遍历。这里**前中后，其实指的就是中间节点的遍历顺序**，例如：

- 前序遍历：**中**左右（中间节点在前）
- 中序遍历：左**中**右（中间节点在中）
- 后序遍历：左右**中**（中间节点在后）

![](./img/前中后序遍历.png)

> 注意，例如遍历的时候前序遍历（中左右），那么左子树的所有节点也要满足中左右，右子树也是如此。