# React 原理篇

## 问题 1：虚拟 DOM 的意义

1. **减少实际的 DOM 操作**：通过比较新旧虚拟 DOM 树的差异，React 可以确定需要更新的部分，并生成最小化的 DOM 操作序列。这样可以减少实际的 DOM 操作次数，提高性能。
2. **批量更新**：React 会将所有需要更新的 DOM 操作批量执行，从而避免了频繁的 DOM 操作，提高了性能。
3. **跨平台兼容性**：虚拟 DOM 是一个轻量级的 JavaScript 对象，可以在不同的平台上运行，例如浏览器、移动设备和服务器。这使得 React 可以在多个环境中使用相同的代码和逻辑。
4. **更好的开发体验**：虚拟 DOM 使得开发者可以使用类似于 HTML 的标记语言来描述 UI，而不需要直接操作 DOM。这简化了开发过程，并提供了更好的开发体验。

## 问题 2：JSX 转为真实 DOM 的过程？

1. **jsx 代码**：

```jsx
return (
  <div className='box'>
    {/* 组件 */}
    <Header>hello</Header>
    {/* 元素 */}
    <div>container</div>
    {/* 文本 */}
    footer
  </div>
)
```

2. **使用 Babel 将 jsx 转为 React.createElement 后**：

> React.createElement(type, props, ...children)

```js
React.createElement(
  'div',
  { className: 'box' },
  React.createElement(Header, null, 'hello'),
  React.createElement('div', null, 'container'),
  'footer'
)
```

3. **创建虚拟 DOM**

`React.createElement` 返回一个描述 UI 的 JavaScript 对象（即虚拟 DOM）。

4. **调用 ReactDOM.render**

使用 `ReactDOM.render` 方法将虚拟 DOM 渲染到指定的挂载容器中。

```js
ReactDOM.render(虚拟DOM, document.getElementById('root'))
```

5. **Diff 算法比较差异**

- React 使用高效的 Diff 算法来比较新旧虚拟 DOM 树之间的差异。
- 只更新有变化的部分，生成最小化的 DOM 操作序列。

6. **批量更新与优化**

React 会将所有需要更新的 DOM 操作批量执行，以减少实际的 DOM 操作次数，提高性能

7. **生成真实 DOM**

最终，React 将这些最小化的 DOM 操作应用到浏览器的真实 DOM 中，完成页面的渲染或更新。

## 问题 3：React DOM 的 diff 算法

React 的虚拟 DOM diff 算法是一种用于比较新旧虚拟 DOM 树的差异的算法，目标是找出需要更新的部分，并生成一个最小化的 DOM 操作序列：

1. **比较根节点**：算法首先比较新旧虚拟 DOM 树的根节点。如果它们的类型不同，那么 React 会完全替换旧的 DOM 树。如果它们的类型相同，那么算法会继续比较它们的属性和子节点。
2. **比较属性**：算法会比较新旧虚拟 DOM 树的属性，判断是否有属性发生了变化。如果有属性发生了变化，React 会更新对应的 DOM 节点上的属性。
3. **比较子节点**：算法会递归地比较新旧虚拟 DOM 树的子节点。如果子节点的数量不同，那么 React 会更新对应的 DOM 节点的子节点。如果子节点的数量相同，那么算法会继续比较它们的类型和内容。
4. **递归比较**：算法会递归地比较新旧虚拟 DOM 树的子节点。如果子节点的类型相同，那么算法会继续比较它们的属性和子节点。如果子节点的类型不同，那么 React 会完全替换旧的 DOM 节点。
5. **生成 DOM 操作序列**：通过比较新旧虚拟 DOM 树，算法会生成一个最小化的 DOM 操作序列，包括插入、更新和删除操作。React 会将这些操作批量执行，从而减少实际的 DOM 操作次数。

## 问题 4：Fiber 架构

- Fiber 是 React 中一种新的架构，它用于实现增量式的、可中断的虚拟 DOM diff 过程。Fiber 的目标是改进 React 的性能和用户体验，使得 React 应用程序更加流畅和响应。
- 在 React 的旧版本中，虚拟 DOM diff 过程是一个递归的过程，它会一直执行直到完成，期间无法中断。这可能会导致长时间的 JavaScript 执行，从而阻塞主线程，造成页面的卡顿和不流畅的用户体验。
- 为了解决这个问题，React 引入了 Fiber 架构。Fiber 将整个虚拟 DOM diff 过程分为多个小任务，每个任务称为一个 Fiber 节点。这些 Fiber 节点被组织成一个树状结构，称为 Fiber 树。
- Fiber 树可以被中断和恢复，这意味着在执行 Fiber 树的 diff 过程时，可以在任意时刻中断当前任务，并优先执行其他任务。这样可以使得应用程序更加灵活地响应用户的交互和其他优先级的任务，提高性能和响应性。
- 通过 Fiber 架构，React 可以根据任务的优先级动态地调整任务的执行顺序，从而更好地控制 JavaScript 的执行。这使得 React 应用程序可以在不阻塞主线程的情况下进行虚拟 DOM diff，减少页面的卡顿和提高用户体验。
- 总而言之，Fiber 是 React 中一种新的架构，用于实现增量式的、可中断的虚拟 DOM diff 过程。它通过将 diff 过程分为多个小任务，并根据优先级动态地调整任务的执行顺序，提高 React 应用程序的性能和响应性。

## 问题 5：为什么 Hook 调用顺序必须一致？

- React 依赖于 Hook 的调用顺序来正确关联状态
- 在每次渲染时，Hook 的调用顺序必须完全相同
- 如果 Hook 调用顺序改变（比如由于条件语句），React 就无法正确跟踪状态

因为在 React 中，Hook 调用顺序必须保持一致是由其内部实现机制决定的，主要原因有以下几点：

1. **React 对 Hook 的管理方式**：
   React 内部通过一个链表来跟踪组件中所有 Hook 的状态。每个 Hook 调用（如 `useState`、`useEffect`）都会对应链表中的一个节点，记录着该 Hook 的状态信息。

2. **依赖调用顺序识别 Hook**：
   React 并不能通过 Hook 的名称或参数来识别不同的 Hook，而是完全依赖于**调用顺序**来匹配对应的状态。例如：

   ```jsx
   function Component() {
     const [name, setName] = useState('') // 第1个Hook
     const [age, setAge] = useState(0) // 第2个Hook

     useEffect(() => {
       /* ... */
     }, []) // 第3个Hook
     // ...
   }
   ```

   React 会默认认为每次渲染时，第 1 个 `useState` 始终对应 "name" 状态，第 2 个 `useState` 始终对应 "age" 状态。

3. **条件判断会破坏调用顺序**：
   如果在条件语句（如 `if`）、循环或嵌套函数中调用 Hook，会导致每次渲染时 Hook 的调用顺序不一致。例如：

   ```jsx
   function Component() {
     if (someCondition) {
       const [name, setName] = useState('') // 可能不会被调用
     }
     const [age, setAge] = useState(0) // 调用顺序可能变化
     // ...
   }
   ```

   当 `someCondition` 为 `false` 时，`age` 状态会被 React 误认为是第一个 Hook，导致状态匹配错误，进而引发难以预测的 Bug。

4. **保证状态一致性**：
   一致的调用顺序确保了 React 能够在多次渲染之间正确关联 Hook 与其对应的状态，这是 React 实现 Hook 机制的基础。

因此，React 官方强制要求：**Hook 必须在函数组件的顶层调用，不能在条件、循环或嵌套函数中使用**，以保证每次渲染时 Hook 的调用顺序完全一致。

## 问题 6：Hooks 的链表结构

React 内部通过**单向链表**结构来管理组件中的 Hooks，这个链表是 Hooks 能够在多次渲染之间保持状态的核心机制。我们可以从以下几个方面理解这个结构：

### 1. 链表的基本构成

每个 Hook 对应链表中的一个**节点**，节点中包含以下关键信息：

- `memoizedState`：存储当前 Hook 的状态（如 `useState` 的值、`useEffect` 的依赖项等）
- `next`：指向链表中的下一个 Hook 节点（形成单向链表）
- 其他元数据：如 `useEffect` 的回调函数、清理函数等

### 2. 链表的创建与更新过程

当组件首次渲染时：

- React 会初始化一个 `workInProgressHook` 指针，指向当前正在处理的 Hook 节点
- 每调用一个 Hook（如 `useState`），React 就会创建一个新的节点，将其添加到链表尾部
- 节点的 `memoizedState` 会存储初始状态，`next` 指针指向下一个新创建的节点

当组件重新渲染时：

- React 会重置 `workInProgressHook` 指针，使其指向链表的头部
- 按**相同的顺序**再次调用 Hooks 时，指针会依次移动到下一个节点，复用之前存储的 `memoizedState`

### 3. 简化的工作流程示例

假设组件中有两个 `useState`：

```jsx
function MyComponent() {
  const [count, setCount] = useState(0);  // Hook 1
  const [name, setName] = useState('');   // Hook 2
  return ...
}
```

- **首次渲染**：

  1. 调用 `useState(0)` → 创建节点 1（`memoizedState=0`，`next=null`）
  2. 调用 `useState('')` → 创建节点 2（`memoizedState=''`，`next=null`），并将节点 1 的 `next` 指向节点 2
  3. 形成链表：`节点1 → 节点2`

- **重新渲染**：
  1. 再次调用第一个 `useState` → 指针指向节点 1，读取其 `memoizedState`（0）
  2. 再次调用第二个 `useState` → 指针移动到节点 2，读取其 `memoizedState`（''）
  3. 保持链表结构不变，状态正确复用

### 4. 为什么顺序不能乱？

如果某次渲染时 Hook 调用顺序改变（比如在条件判断中调用）：

```jsx
function MyComponent() {
  if (someCondition) {
    const [count, setCount] = useState(0) // 可能不执行
  }
  const [name, setName] = useState('') // 顺序错乱
}
```

- 当 `someCondition` 为 `false` 时，第一个 `useState` 不执行
- 重新渲染时，React 会将第二个 `useState` 误认为是第一个 Hook，去读取节点 1 的状态（原本属于 `count` 的值）
- 导致状态匹配错误，出现数据错乱或异常

### 总结

Hooks 的链表结构依赖**调用顺序**来关联状态，每次渲染时通过指针依次访问节点。这种设计让 React 能够高效地管理多个 Hook 的状态，而无需额外的标识（如变量名）。这也是为什么 React 严格要求 Hooks 必须在组件顶层调用，不能放在条件、循环等可能改变执行顺序的代码中。

## 问题 7：React 的 hooks 的原理是怎样的

React Hooks 的原理可以从以下几个核心角度来理解：

1. **Hooks 依赖于调用顺序**

   React Hooks 必须在函数组件的顶层调用，不能在条件语句、循环或嵌套函数中使用。这是因为 React 内部通过一个**单向链表**来管理 Hooks，每次调用 `useState` 或 `useEffect` 时，都会按顺序将其添加到链表中。

   当组件重新渲染时，React 会按相同的顺序读取链表中的 Hooks 信息，从而保证状态的正确性。如果调用顺序改变，会导致 React 无法正确匹配 Hooks 与对应的状态。

2. **状态存储机制**

   - 每个函数组件都对应一个 **Fiber 节点**（React 内部工作单元）
   - Fiber 节点中包含一个 `memoizedState` 属性，用于存储该组件的 Hooks 链表
   - `useState` 会创建一个包含状态值和更新函数的对象，并将其添加到链表中

3. **闭包的作用**

   Hooks 严重依赖 JavaScript 的闭包特性。每次组件渲染时，都会创建新的函数作用域，而 Hooks 内部通过闭包保留对当前状态和 props 的引用。

   例如，`useEffect` 的回调函数会捕获定义它时的状态和 props，这就是为什么当依赖项变化时需要重新运行 effect。

4. **依赖项数组的工作原理**

   `useEffect`、`useCallback` 等 Hooks 接受一个依赖项数组作为参数。React 会在每次渲染时比较依赖项数组中的值：

   - 如果所有值都与上一次渲染相同，则跳过执行
   - 如果有任何值发生变化，则执行相应的回调函数

   这种机制让 React 能够优化性能，避免不必要的计算和副作用。

5. **Hooks 的本质**

   Hooks 本质上是对函数组件内部状态和生命周期的抽象封装。它们允许在不编写类组件的情况下使用状态和其他 React 特性，同时保持代码的可组合性和可重用性。

简单来说，React 通过维护 Hooks 调用顺序和利用闭包特性，让函数组件能够拥有状态和副作用处理能力，同时保持了简洁的 API 和良好的性能。
